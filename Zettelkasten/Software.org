* copy and paste
- "+ vorgeschaltet, präzisiert das clipboard (register)
- y => kopiert in kill ring
- p => pastet aus kill ring
- "a y / p => kopiert/pasted in/aus register a
- M-v paste aus Clipboard durch emacs
- C-@ setzt mark (ab da wird markiert)
- C-Shift-v paste im Terminal
- "+ ;y kopiert Link in pentadactyl
- C-einfügen kopieren durch Emacs
* generelle Software
 + aumix oder alsamixer für soundsteuerung
 + alternativ einfach sound bei kupfer
 + evince ist der pdf viewer
 + Synergy zum Maus/Tasta sharen
   1. auf beiden quicksynergy starten
   2. server ip (ifconfig) bei client eintragen + name
   3. diesen Namen bei server in richtung eintragen und executen
   4. client executen
 + xrandr:  $ xrandr --output VGA --mode 1280x1024 --right-of LVDS
 + convert pic123.png resize 10% res_pic.png  :: resizing
** Tasten remappen
xvkbd -xsendevent -no-sync -delay 20 -text "-"
xbindkeys --default > /home/florian/.xbindkeysrc
xbindkeys-config    <= und da den xvbkd kram einstellen
* synergy
** keyboardlayout
- nacktes setxkbmap beim client hilft
** ServerConf
#~/.synergy.conf
section: screens
	florian-ThinkPad-X121e:
	flo_laptop:
end
section: links
	florian-ThinkPad-X121e:
		left = flo_laptop
	flo_laptop:
		right = florian-ThinkPad-X121e
end
section: options
	 keystroke(control+1) = switchInDirection(left)
	 keystroke(control+2) = switchInDirection(right)
end 
** ClientConf
conf wird gar nicht geladen o.O
Aufruf:
synergyc -n flo_laptop 192.168.2.30
* Orgmode
** shortcuts-orgmode 						  :shortcuts:
    C-c C-c         Tags zu Unterpunkt verwalten / Latex lösen
   C-c C-x C-l     Latex Code an aktueller Stelle übersetzen
   my-org-screenshot Screenshot-Ausschnitt erstellen und einfügen
   Latex Org Mode oder sowas aktiviert lustige makros
   pattern matching von vim funktioniert zum navigieren!!

   C-c C-n /p für nächsten /vorherigen Header
   C-c C-u um wieder zum Header zu kommen
   C-k / C-j nächster / vorheriger Header auf selber Stufe
   
   C-n    dynamic extension !!!
** inline bilder
*** link_linie entfernen
(set-face-underline-p 'org-link niPl)
mit org-display... gibts keine
Linien, und es reagiert sofort
*** bilder anzeigen
iimage-mode / iimage-recenter
[ [file:datei123.png] ]

alternativ:
org-display-inline-images
<= zeigt direkt keine linie
** Regionen/Enviroments
= org-special
- tangling wert ungleich yes und no wird als Dateiname interpretiert
- mit org-babel-tangle werden dann die Dateien erstellt
*** Syntax
#+BEGIN_X
#+END_X

#+BEGIN_LaTeX
\documentclass ...
#+END_LaTeX
*** Allgemeines
- wird auf jeden Fall anders formatiert(alles grau)
- durch Variable org-src-fontify-natively wird auch
  im Org-Fenster das richtige Syntaxhighlighting 
  im Codeblock benutzt
- C-c ' :: öffnet den Inhalt der Region tempoär in nativem Buffer. Dieser
	   muss mit der selben Tastenkombination beendet werden
*** Beispiel Syntax mit möglichem Tangling

#+BEGIN_SRC latex :tangling st-temp.tex
  \documentclass[11pt]{amsart}
  
  \begin{document}
  $\frac{A+B}{C+D} = X*Y = \binom{123}{456}$
  \end{document}
#+END_SRC

*** streaming
- leider noch keine Möglichkeit gefunden das ganze mit externen Dateien zu verknüpfen,
was ist mit Annotationen?
- das würde normalerweise auch erst beim exportieren gemacht werden (Stichwort: tangling)
- für Code Tangling bieten sich dann die 

* org-protocol
** Browser
javascript:location.href='org-protocol://capture://x/'+
      encodeURIComponent(location.href)+'/'+
      encodeURIComponent(document.title)+'/'+
      encodeURIComponent(window.getSelection())

Sendet diese Daten an Emacs Template, (hier konkret x aber kann 
man auch weglassen)
** Emacs
(setq org-capture-templates
      (quote
       (("w"
         "Default template"
         entry
         (file+headline "~/Zettelkasten/zettelkasten.org" "Notes")
         "* %^{Title}\n\n  Source: %u, %c\n\n  %i"
         :empty-lines 1)
        ;; ... more templates here ...
        )))

- Ersetzt templates durch liste mit diesem Template
- Name Default template mit key w
- Subtree mit manuell eingegebenen Titel, unter Überpunkt
  Notes mit aktuellem Datum und dem Titel der source
- überall ne leere zeile dazwischen
* Vim
** Search/Replace                                                :shortcuts:
	    =Änderungen werden komplett live gepreviewed=
	    :bereichs/foo/bar/g  oder gc
	    als Bereich kann man z.B. mit a',b' marker angeben
	    Ferner sind auch . für die akt Zeile oder konkrete
	    Zeilennummern möglich, geht aber auch +2 = relativ zu cur-pos
	    oder anders:
	    :g/^test/s/foo/bar/g  nur zeilen die mit test anfangen
** Mehrfachmanipulation
v -> visual, V -> visual zeile, ctrl v -> block
dann mit i,a,I,A usw. editieren (nach enter bei allen zeilen)
** kleinkram
s(jetzt k) löscht geht aber direkt auf insert
:w !sudo tee > /dev/null %  wenn die Berechtigung bei Vim fehtl
    alternativen: :%!sudo tee %
sudo chmod -v -R ouag+rw *     alles per chmod freigeben

** Vervollständigung
   - Ctrl+n für dynamische 
     Vervollständigung / Ctrl+p für letzte Vervollständigung (sucht
     im Text auch in genau diesen Richtungen !! )
   - Ctrl+x Ctrl+n und Ctrl+x Ctrl+p um ganze 
     Zeile so zu vervollständigen
* Emacs
** shortcuts-emacs 						  :shortcuts:
    sudo chmod -v -R ouagrw . matched auch verstecktes
   - igrep und dann regex um dateien zu (durch-)suchen
   - recentf-open-files ::   zeigt die letzten dateien an
   - deft-new-file ::        erstellt eine kurznotiv die mit deft
     zusammengefasst werden können
   - C-x C-e :: führt aktuelle lisp zeile aus und gibt ergebniss aus
   - M-esc : :: eval-expr
   - C-x b  ::  buffer wechseln
   - winner-undo :: Layout wiederherstellen (tempoärer speicher)
   - repeat :: .
   - vergrößern/verkleinern :: C-x } /
   - finde Buffer :: C-x 4 C-o
   - InsertPoint :: Ctrl + w (mehrfach für größere Fläche

   - save-current-configuration :: C-ä w
   - resume :: C-ä c
	       
   - show shortcuts :: C-ä x
** Hilfefunktionen
-    M-x apropos :: findet alles was irgendwie mit dem Ausdruck danach zu tun hat
-    F1 / M-x Helper-... :: findet Keybinds <=> Funktion usw
-    apropos-documentation :: durchsucht alles nach einem String

** Tmp Keymaps
    blablabla
    testtest
    testetst

    einfach zeile yanken, eval-expr.. und paste mit ctrl-y
    oder auf zeile und C-x C-e, oder markieren und eval-region
      (global-set-key (kbd "C-ß") 'clipboard-yank) *nichtmehr notwendig*
      (global-set-key (kbd "C-c f") 'evil-emacs-state)
      (global-set-key (kbd "C-c q") 'evil-force-normal-state)
      (define-key evil-normal-state-map (kbd "C-c f") 'evil-emacs-state)
      (define-key evil-normal-state-map (kbd "C-c q") 'evil-force-normal-state)
      (global-set-key (kbd "C-u") 'evil-scroll-up)
      (define-key evil-normal-state-map (kbd "C-u") 'evil-scroll-up)
      (global-set-key (kbd "M-k") 'evil-window-prev)
      (define-key evil-normal-state-map (kbd "M-k") 'evil-window-prev)
      (global-set-key (kbd "C-c b") 'view-buffer-other-window)
      (global-set-key (kbd "C-ü") (lookup-key global-map (kbd "C-x")))

      (global-unset-key (kbd "C-d"))
      (local-unset-key (kbd "C-d"))
      (global-unset-key "\C-d")
      (local-unset-key "\C-d")

      (global-set-key (kbd "C-d") 'evil-scroll-down)
      (define-key evil-normal-state-map (kbd "C-d") 'evil-scroll-down)
      (define-key evil-motion-state-map (kbd "C-d") 'evil-scroll-down)
      (local-set-key (kbd "C-d") 'evil-scroll-down)
       (define-key evil-normal-state-map "\C-d" 'evil-scroll-down)
      (define-key evil-motion-state-map "\C-d" 'evil-scroll-down)
      (local-set-key "\C-d" 'evil-scroll-down)

      (define-key global-map "\C-d" 'evil-scroll-down)

      (define-key local-map "\C-d" 'evil-scroll-down)

; freie Präfixe sind C-ü , C-ö , C-ä



      [[file:~/.emacs::(global-set-key%20(kbd%20"C-c%20b")%20'][.emacs]]

** Funktionen für Elisp
    - (global-set-key [key] 'func)
        - statt [key] kommen auch strings wie "\C-r" "\M-r" usw. in Frage
        - andererseits geht auch (kbd "C-r")
    - count-lines-page


*** jump to empty line
**** Next Line Code
(defun jumpToNextEmpty ()
  (interactive)
  (let (var1 moreLines startpoint)
    (setq moreLines (> 2 1))
    (setq startpoint (point))
    (while moreLines
       ;(setq moreLines (= 0 (forward-line 1)))
       ;(forward-line -1)

       ;(message "%s" moreLines)

       ;(setq moreLines (next-line 1))
       ;(setq moreLines (= 0 (next-line 1)))
       (if moreLines
	  (let (p1 p2)
	    (next-line 1)
	    (setq p1 (line-beginning-position))
	    (setq p2 (line-end-position))

	    (when (>= p2 (buffer-size))
	      (setq moreLines (< 2 1))
	      (goto-char startpoint)
	      )

	    (setq var1 (buffer-substring-no-properties p1 p2))
	    (when (string-match "^[ \t]*$" var1)
	       (message var1)
	       (setq moreLines (< 2 1))
	       )
	   )
	 )

       )
    )
 )
**** Prev Line Code
(defun jumpToPrevEmpty ()
  (interactive)
  (let (var1 moreLines startpoint)
    (setq moreLines (> 2 1))
    (setq startpoint (point))
    (while moreLines
       (if moreLines
	  (let (p1 p2)
	    (next-line -1)
	    (setq p1 (line-beginning-position))
	    (setq p2 (line-end-position))

	    (when (<= p1 1)
	      (setq moreLines (< 2 1))
	      (goto-char startpoint)
	      (message "no empty lines found")
	      )

	    (setq var1 (buffer-substring-no-properties p1 p2))
	    (when (string-match "^[ \t]*$" var1)
	       (message var1)
	       (setq moreLines (< 2 1))
	       )
	   )
	 )
       )
    )
 )
*** unique filename
(setq filename
	(concat
	 (make-temp-name
	  (concat 
		  ""
		  (format-time-string "%Y%mad-%H%M%S"))
*** write file
(with-temp-buffer
  (insert (string-as-multibyte "\\test bla"))
  (insert (string-as-multibyte (concat "a" "b" "c")))
  (insert var1)
  (write-region (point-min) (point-max) filename))
*** shell-command
(shell-command
  (concat "latex " filename ".tex"))
*** my-make-latex
(defun my-make-latex ()
  "Convert Region to a Latex image"
  (interactive)
  (setq filename
	(concat
	 (make-temp-name
	  (concat 
		  ""
		  (format-time-string "%Y%mad-%H%M%S")))""))

  (setq stuff (buffer-substring (region-beginning)(region-end)))
  
  (with-temp-buffer
    
    (insert (string-as-multibyte "\\documentclass[11pt]{standalone}"))
    (insert (string-as-multibyte "\\usepackage[utf8]{inputenc}"))
    (insert (string-as-multibyte "\\usepackage{amssymb, amsmath}"))
    (insert (string-as-multibyte "\\begin {document}"))
    (insert (string-as-multibyte "$"))

    (insert stuff)

    (insert (string-as-multibyte "$"))
    (insert (string-as-multibyte "\\end{document}"))

    (write-region (point-min)(point-max) (concat filename ".tex")))
    
  (shell-command
   (concat "latex " filename ".tex"))

  (shell-command
   (concat "dvipng " filename ".dvi -o " filename ".png"))

  (insert (concat "[[file:"filename ".png]]"))
  (iimage-recenter)
)
(provide 'my-make-latex)

*** get selection/region
(setq stuff (buffer-substring (region-beginning)(region-end)))
** Funktionsaufruf(shortcut) durch neuen ersetzen(key)
(define-key (current-global-map) [remap kill-line] 'my-homemade-kill-line)
** bedingung
(when (string-match "^ *$" test-str)
   (message "cool")) 
** eine Zeile vorwärts
(forward-line 1)   ; oder auch -1
** hartnäckige Bindings überschreiben
die Minormodes habflorianen eine der höchster Prioritäten beim nachschlagen der Keys
-> der jeweilige evil minor mode bietet sich an
Generell gilt: (current-local-map) <= ist ne funktion
Wenn einige Modes ihre Bindings aber trotzdem noch drüberschreiben, muss man sich
selbst an die Hook ketten:
(add-hook 'evil-insert-state-entry-hook
 (lambda ()
 (define-key evil-insert-state-local-map "\M-j" 'evil-window-next)
 (define-key evil-insert-state-local-map "\M-k" 'evil-window-prev)
 )
)
** helm :shortcuts:
[Space] scrollt in Hilfstext
M-a markiert alle Einträge !!!

** Zeilenumbruch
   + linewrapping = darstellungsumbruch
   + truncating = nicht umbrechen
     => toggle-truncate-lines
   + columnfilling => zeilenumbruch im Buffer
     => auto-fill-mode bricht automatisch um
     => set-fill-column setzt die max. Zeichenanzahl
* install/make kram
1. ./configure
2. make
3. sudo make install
* Firefox
** Standardsuche
about:config und da nach keyword.URL suchen und
https://www.google.com/search?hl=en&q=  einsetzen

** Extensions
+ Bugmenot
  viel zu viel gesperrt und son Scheiß. Für die Fälle wo's sich trotzdem
  lohnt, reicht auch die Website
+ CoolPreviews
  meine fresse ist das eine langsame Reaktion gewesen
  die Suchen funktioniert irgendwie nicht, und auch sonst ist
  die Reaktionszeit für normale links extrem langsam, das Interface
  selbst ruckelt auch pervers
  andererseits kann das von Zeit zu Zeit sicherlich auch Tabs einsparen
  auch wenn kurz öffnen und zurückgehen vermutlich schneller wäre
  die stacking funktion ist auch irgendwie scheiße weil langsam und unübersichtlich
  könnte aber fürs nächste vielleicht zu mehr ordnung motivieren
+ DeeperWeb
  also dezent würd ich die sidebar nicht grade nennen, stopft das halbe fenster zu
  der Wert der angezegiten Tags ist 'begrenzt'
  teilweise sind aber interessante Suchansätze implementiert, deren Umsetzung ist zwar
  Scheiße, aber auf Basis dessen lässt sich sicherlich noch besseres finden
+ DownloadHelper
  integriert sich ganz gut und enthält einen converter, nichts auszusetzen
+ Element Hiding Helper Adblock Plus
  funktioniert ziemlich gut -> seiten lassen sich schnell extrem vereinfachen
  -> leider kein redo oder preview?
+ Fasterfox
  konnte bisher keinen Echten leistungsanstieg feststellen
+ fastestfox
  verschiedene "downthemall-artige" Funktionen
  diese kleinen buttons beim link sind eigentlich nur nervig und schwul
  aber die kleine wikipedia preview für markiertes könnte praktisch werden
  automatisches laden der nächsten seite führt öfters mal zu problemen
  Geht mir jetzt schon auf die nerven
+ Instaright!
  wieder so behindert fokussiert auf die eigene Seite
  sehr ruckelige Angelegenheit und bescheuerte Notifications
  behindertes Scheißteil -> weg
+ Multirow Bookmarks
  haben jetzt auch auf ein neues Plugin mit plus am Ende umgestellt >.>
  ficken sie sich
+ Pocket
  bietet die möglichkeit halbwegs effizient die links zu sammeln und synchronisiert
  die dann mit deren Server
  paar shortcuts gibts auch, aber die reichen noch nicht wirklich
+ Read Later Fast
  zwar immernoch scheiße weil immer auf extra Seite, aber bis auf weiteres muss das
  reichen, irgendwie auch etwas verbuggt
  Korrigiere: funktioniert nicht
+ SearchMenu
  klein, schmal und unauffällig, erfüllt seinen Zweck
+ Tile Tabs
  normale Tabs Funktionieren nicht so ohne weiteres,
  => läuft über separates Menü(scheint umschaltbar zu sein)
  ist trotzdem scheiße
+ Vimperator
  im Prinzip schon ziemlich geil, flexibel und bietet viele Möglichkeiten
  im Moment sieht das Design markierter links aber noch echt kacke aus
  und er krallt sich andauernd irgendwelche Tastendrücke und macht
  scheiße damit
  speichert auch die Einstellungen irgendwie nicht
** org-protocol
*** emacs.d
(server-start)
(require 'org-protocol)
*** browser
in ~/.local/share/applications
org-protocol.desktop erstellen mit

  [Desktop Entry]
  Name=org-protocol
  Exec=emacsclient %u
  Type=Application
  Terminal=false
  Categories=System;
  MimeType=x-scheme-handler/org-protocol;

und update-desktop-database ~/.local/share/applications/ laufen lassen
in Firefox dann url öffnen und /usr/bin/emacsclient zeigen
** kopieren
/ -> suche, um zur richtigen stelle zu kommen
c -> caret mode;
v -> visual mode;
dann y -> yank

* Shell
- mit history durchnummerierte Befehlshistory
- schleife in bash :: for i in {1..10}; do echo $i;done
- inhalt durchsuchen :: grep --context=10 oder -C 10   (<- großes C)
- replace :: sed -i 's/old-word/new-word/g' *.txt
- rename :: rename 's/\.bak$//' *.bak
- ausgabe :: cat
- argumente :: !$ (last) !n:1 (arg1 von cmd n)
- befehle :: !! (last) !n (nr) !ls (last ls) ^ust^usr (last mit 1 replace)
- dir :: cd - (last dir) pushd / (cd mit stack) popd (zurück stack)
- ausschnitt :: head -n 2(bis 2) tail -n 2(ab) head -n -2(bis letzte 2)
- einsetzen :: sed -i~ '1 i anfang' Server.java (setzt in zeile 1 ein, ~ = Backup)
- entfernen :: sed -i '1 d' Server.java (löscht Zeile 1)
- variablen/zwischenspeicher :: set varname = blakramzeug
* yas
** neu erstellen
Ctrl-ä n  -> neu
Ctrl-ä t  -> load buffer
-> fertig
der key wird dabei expanded
** Beispiel Snippet
# -*- mode: snippet -*-
# name: leftrightarrow
# key: Lra
# --
\Leftrightarrow
** Input
${1} für Eingaben, ${1:bla} oder sows für Vorschläge
dann Lra in Latex eingeben und tab -> ersetzung
Bei kopien wird dann bloß noch $1 geschrieben
(muss auch!! Die klammern sind nichtmehr erlaubt)
Für mehrere Auswhal möglichkeiten:
<div align="${2:$$(yas/choose-value '("right" "center" "left"))}">
* git
   *HEAD -> Branch -> Commit*
** Keywords
(teilweise direkt mit git <keyword> als befehl)
- ref :: reference, verknüpfung, konkret id oder so
- repository :: Container mit Daten / Veränderungen und allemm
- commit object :: dateien, die den aktuellen stand zu zeitpunkt
		   repräsentieren (hat auch n namen und so)
		   oft auch nur veränderungen und link zu parent
- head :: ref auf commit objekt, im grunde nur id/name (= sha1)
	  HEAD ist der akt. aktive vom akt. Repo
- branch :: unterschiedliche ableitungen eines repositories, für gewöhnlich
    also daher durch head repräsentiert (entspricht besonderem commit, häufig tempoär)
- merge :: (synt.: git merge [head]) pflegt das commit objekt von head
	   in das aktuelle repository ein
	   -> sucht gemeinsamen vorfahren, von akt. commit und neuem
	   -> wenn alles glatt geht einfach überschreiben, sonst manuelle entscheidungen
	    bzw. entsprechende Marker um User zu warnen
	   -> Konflikt, beide Mergehistorien haben zu gleichem Zeitpunkt widersprüchliche
	    Änderungen
	   sonst Fast Forward, jeweils immer nur eine Veränderung( geht automatisch)
- checkout :: HEAD auf commit lenken, und dann die lokalen Daten überschreiben;
	     konzentriert sich dabei auf staged files und so
- diff :: unterschied zwischen 2 commits (also heads übergeben)
- log :: commit zur tempoärem Vorgänger
- remote :: repository das nicht lokal ist
	    remote repository bekommt rem rep ref (standard origin) als identifikation
	    remote heads, verlinken die heads(-> commits) in rem rep
	    (syn.: origin/[head-name]
- track :: lokaler branch repräsentiert intern remote branch (tracked diesen also, ist ref)
	   alle notwendigen Daten liegen lokal abgespeichert
- fetch :: neue commits aus getracktem branch werden in trackendem branch gesichert
	   nur remoteheads verändern sich
- master :: lokaler hauptbranch (standardmäßig), kann auch selbst tracken
- pull :: passt die heads dem fetch an (wenn tracking eingerichtet, erfolgt erkennug
	  des remote repositories und vorhergehender fetch automatisch
	  übernimmt dabei also vorrangig allos von eimen (meist remote) Rep
- push :: fügt remote repository die commits hinzu und der lokale headlink wird zu der
	  passenden Modifikation weitergeleitet
	  remote head reference usw. werden in lokalme branch auch angepasst
	  ! rem head muss zu vorgängen von akt. rem rep zeigen und dort einsetzen!
	  -> fast forward merge wird forciert
- index :: sammlung der dateien, die zum repository committed werden sollen
	   bilden die Grundlage um commit objekte zu bilden
- commit :: bilden und hinzufügen von commit objekten zu repository
- working directory :: der ordner in dem die daten liegen, die man selber wirklich bearbeitet
- stash :: container für nicht committete Modifikation, um mit akt. rep zu mergen
- status :: zeigt differenzen: working-directory <-> index <-> aktuellster commit
	    => wd enthält alle dateien, index nur 'tracked' dateien, und akt. commit die 'staged',
	    die nach bisherigem Stand auf jeden fall reinkommen.
- staged :: fürs nächste commit vermerkt
- reset :: setzt den HEAD 'link' zurück, (zu spezifischem Stand),
- mv|rm|ect :: können dies jeweils in workdir aber auch pushbaren commits machen
	       und den Rest auch gleich anpassen
** dateien aus dem kreislauf ziehen (aber erhalten)
1. in underordner und .git/info/exclude jeweils ausnahme hinzufügen
2. git update-index --asume-unchanged <filepath>    ab -- vlt optional
3. git rm --cached filepath
4. git update-index --asume-unchanged <filepath>    keine ahnung ob nochmal

5. git commit -m "bla"
6. git push
** dateien hinzufügen/updaten
ob eine Datei  ganz neu ist, oder sich nur verändert hat, macht erstmal
   keinen Unterschied. Mit git add werden Dateien hinzugefügt.

** spontan konkretes committen
    git add --patch     lässt dann wählen was gemacht wird
** lokalen datenbestand updaten
git pull

git checkout
git
** Ganz neues Projekt
1. Mit git initialize oder so, erstmal lokal rep erstellen
2. Online irgendwo was erstellen
3. git remote add name pfad
4. git update name
5. git commit -m "bla"
6. git fetch name
7. nochmal add und commit
8. git pull name -t master
9. git commit -m "bla"
10. git push name
11. config mit default remotes updaten:
    [branch "master"]
    remote = origin
    merge = refs/heads/master
** neue basis pushen (überschreiben)
git push remote_name --force
** neues system mit online repo verbinden
git init     für neues lokales rep
git add      mit allem was man dabei haben möchte, ggbflls. vorher gitignore
git remote add rem_name online_path -t master
(git push rem_name --force) falls repository neu bespielt werden soll
** Fehler beheben
- mit git log die einzelnen commits inkl nummer anzeigen
- mit git show nr:pfad z.B. 1234:.emacs.d/test.txt dokumente etc anzeigen

* eshell
- cd = für stack, cd -nr  um aus stack aufzurufen

* zipper
- tar.gz :: tar xvfz filepath
- zip :: unzip filepath
* Latex
- latex selbst konvertiert zu dvi
- programme wie dvipng machen daraus bild
- documentclass[11pt]{standalone} erstellt
  eine Seite mit minimaler größe (für formelextraktion)
- iimage-mode <- zeichnet einfache links zu bildern
  iimage-recenter läd die bilder dann nach
 
** beispiel image link
[ [ file:~/test1.png ] ] 
; das file: am anfang ist wichtig!
** minimales latex Skript
\documentclass[11pt]{standalone}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}

\begin{document}
$\frac{A}{B} = c$

\end{document}
 
* Windowmanager

   :PROPERTIES:
   :ID:       0001
   :END:
** *Kriterien*
  - hohe Geschwindigkeit und Ressourcensparend

  - sollte die Standardlayouts schnell aufbauen können
  - intuitives Verändern der Layouts per Tastatur (größe und pos der Felder)
  - zuordnen mehrerer Workspaces bzw. Tags / Gruppen
  - einfache Konfiguration, am besten Live/über GUI oder tool
  - aktive Entwicklung
  - vorhandensein und kompatibilität zu wichtigen widgets
  - Maus ist immernoch -möglich-
  - schnelles setzen des Fokus auf konkretes Fenster möglich
** *Theorie*
DynamicWindowManager :: tiling *und* freies Verteilen
TilingWindowManager :: Fenster liegen nie übereinander
StackWindowManager :: Fenster können übereinander liegen

** Awesome WM
- tagging ganz cool aber auch nicht mehr als mehrfache workspace
  zuordnung
- jede Konfiguration über die Datei, nichts geht einfach über
  Packagemanager
- Widgets machen irgendwie Probleme und Design von Fenstern scheiße
- Focus Management noch nicht perfekt, generell mangel an
  Usability Innovation
- zuschalten von Fenstern geht flüssig, schnell und sauber
*** Fenster in bestimmten Tags starten
 -- {{{ Rules
awful.rules.rules = {

    -- All clients will match this rule.
    { rule = { },
      properties = { border_width = beautiful.border_width,
                     border_color = beautiful.border_normal,
                     focus = true,
                     keys = clientkeys,
                     buttons = clientbuttons,
                     size_hints_honor = false} },
    { rule = { class = "MPlayer" },
      properties = { floating = true } },
    { rule = { class = "Chromium" },  properties = {tag = tags[1][1]}},
    { rule = { class = "Luakit" },  properties = {tag = tags[1][1]}},
    { rule = { class = "Geany" },  properties = {tag = tags[1][2]}},
    { rule = { class = "libreoffice-writer" },  properties = {tag = tags[1][2]}},
    { rule = { class = "Terminator" },  properties = {tag = tags[1][3]}},
    { rule = { class = "Vlc" },  properties = {tag = tags[1][4]}},
    { rule = { class = "Desmume" },  properties = {tag = tags[1][4]}},
    { rule = { class = "Easytag" },  properties = {tag = tags[1][4]}},
    { rule = { class = "Galculator" },  properties = {tag = tags[1][4]}},
    { rule = { class = "Gpartedbin" },  properties = {tag = tags[1][5]}},
    { rule = { class = "Gtg" },  properties = {tag = tags[1][5]}},
    { rule = { class = "Pcmanfm" },  properties = {tag = tags[1][5]}},
    { rule = { class = "Transmission" },  properties = {tag = tags[1][5]}},
}
-- }}}
*** shortcuts-awesome wm 					  :shortcuts:
S-n       :: minimieren
S-C-n     :: wiederherstellen
^S-c      :: schließen
S-t       :: oberste Ebene
^S-j / k  :: Fenster verschieben
S- h/l    :: Breite verändern
^S-h/l    :: mehr/weniger Hauptfenster
S-C-h/l  :: mehr/weniger Spalten Slaves
^S 1-9    :: ändere Fenster tags auf 1-9
^S-C 1-9  :: Füge Fenster Tag hinzu

*** mehrere Bildschirme
- mit dem xrandr Befehl aus dem Softwarebreich starten
- mit mod4+o werden die Fenster verschoben
- mit mod4+ctrl wird der fokusmonitor gewechselt
** wmii :kandidat:tested:
- Ressourcensparend
- sehr nah an z.B. DWM aber mit mehr Features etc.
- Features haben auch keine offensichtlichen Makel
- kann in beliebigen Sprachen entwickelt und verändert werden
- es existieren viele Pakte solcher Modifikationen
*** Test
- shell funktioniert auf anhieb
- sondertasten neo nicht im startmenü, was aber ansonsten ganz gut läuft
- scrollbars irgendwie eigenartig
- ruckelige Darstellung
- tagzuweisung klappt ganz gut
- generell, sobald maus benutzt wird wirkt alles verbuggt
- autofokus auch erstmal nicht drin
- design sehr minimalistisch <- hat nen eigenen reiz
- zusammenklappen ist aber ziemlich intelligent:
  ein Fenster kann per Knopfdruck auf die komplette Spalte maximiert
  werden und der rest wird nur am rand eingeblendet
- Shortcuts
  [[/home/florian/Dropbox/Zettelkasten/zettelkasten.org_20121213_230622_11330eFl.png]]
  - mod t = springe zu tag, mit shift auch setzen
(Press "Alt + a" to log out, well select "exit")

- ganz geil ist, das man nicht auf tagnummern achten mussten
  sondern einfach anfängt den namen einzugeben und dann codecompletion
- das Springen zwischen Master und dem Rest ist wirklich gut umgesetzt
  (einfach durch sprung nach links/rechts usw)
- zB der DocumentViewer läuft ganz gut und kupfer geht auch
- emacs verhält sich auch nicht auffällig
- tagnummer mappt nicht auf unterschiedliche Namen? oO
- die Balken die noch da sind, sind aber eigentlich auch nur störend
** Qtile :kandidat:tested:
- basiert auf python
- noch recht schnell und klein, leicht modifizierbar
- hat auch ne nett gemachte Projektseite usw.

*** Test
- design im Kern sehr schick und sehr spartanisch
- modifizierung über python scheint auch gut möglich zu sein
- das standardmäßig vorgegebene beispiel ist aber schrott
** Xmonad :kandidat:tested:
popluär, flexibel und frei, auf jeden fall
ein kandidat
http://xmonad.org/tour.html
*** Test
- Termninal läuft
- Fensterbalken und son Kram existieren nichtmal
- schafft es aber offensichtlich nichtmal, die windowstaste als mod zu benutzen
- kupfer funktioniert
- die layouts entsprechen erstmal nur den elementarsten basics
- dank dmenu die selbe menüleiste wie bei wmii aber nicht dauernd eingeblendet und neo
  läuft ordentlich
- sehr minimalistisch aber irgendwie schon schick
- alles weitere müsste nachgerüstet werden, aber in diesem Fall
  wäre xmonad sicherlich ein gutes fundament
- plugins laufen über haskell
** herbstluft :kandidat:
- "nachfolger" von Musca
- scheint alles wichtige drin zu haben
- das reicht fürn test

- so auf anhieb geht gar nichts und besonders
viel scheint das internet auch nicht dazu zu haben
- generell noch relativ neu (kaum ein jahr alt)
<.< immernoch nichts geschafft
- wird erstmal auf später verschoben

http://wiki.ubuntuusers.de/herbstluftwm

** wmfs :kandidat:
- scheint alles zu bieten

** i3wm :kandidat:tested:
- hardcore simpler einstieg ABER wlan wird direkt angezeigt
- battery widget auch da, funktioniert aber nicht
- bäh, kupfer bekommt diesen schwuler rahmen aufgezwungen
- erstmal abgestürzt
- steuerung ist aber nicht ungeil (mit simulierten pfeiltasten fenster positionieren
- und die stacks sind drin, die sind schon ziemlich cool
- allzu leicht ist das herstellen eines ganz konkretn aufbaus trotzdem nicht
- stacking ist aber echt geil, und tabbing genauso, sau nützlich
  - leider gibt es jedes mal grelles flimmern beim umschalten
- containern kann man auch irgendwie
- viele wirklich interessante Konzepte umgesetzt, sollte in jeden Fall
  als Referenz für zukünftige Projekte in die Richtung dienen
- viele kleine grafikfehler
- und die tasten werden für shortcuts nach der hardware und nicht neo geladen

** spectrwm :kandidat:tested:
- aktuell und fleißig bearbeitet, alles bestens

- erster blick sehr spartanisch
- fenster sieht am rand etwas kaputt aus
- kupfer funktioniert
- reagiert auch wieder auf alt statt tab
- master kleiner oder größer machen
  ruckelt echt übel
- ansonsten der ganze Standardkram ist sauber umgesetzt
- leider keine echte benennung der layer?
- jedenfalls nichts was es besonders macht
** *----------------------------*
** Fluxbox :rejected:
- bietet zuordnung in tabs an( => Programme die sich auf
  viele Fenster verteilen können zusammengefasst werden)
*** Comment: gleichzeitige Anzeige?
? die Frage ist, ob auch mehrere Tabs gleichzeitigen in einem
Fenster angezeigt werden können, wenns sein muss
+ das selbe Ergebniss lässt sich auch generell mit Tags und workspaces
erreichen

- alle benötigten bars etc. würden sich nachrüsten lassen
- kein tiling -> und tschüss
** UWM :rejected:
- keine Taskleiste usw. => vesucht flexibel produktiv zu bleiben
- dabei allerdings starker fokus auf die Maus
** IceWM :rejected:
- minimalistisch usw. bietet im Endeffekt aber auch nichts wirklich
innovatives oder tolles
** OpenBox :timefiller:
- sehr schnell und beliebt
- kann im Grunde auch nicht mehr
- aber eben wirklich hart ressourcen sparend
- sehr stark und simpel modifizierbar in alle Richtungen
- Tiling nur über über PyTile -> recht Ram aufwendig
** Musca Wm :rejected:timefiller:
- die auswahl der Fenster wirkt sehr spartanisch, mit einfachen
Linien um die Layouts zu bestimmen
- scheinbar auch nicht gerade besonders verbreitet
- die Leute scheinen aber recht begeistert von der Aufteilung
  und der Fenstersteuerung zu sein
*** Readme (sehr groß) mit allen Infos
Musca

- Musca

|@constellation_small.png right@|http://en.wikipedia.org/wiki/Musca| |controls|#controls| : |source|#source| : |author|#author| : |bugs|https://bugs.launchpad.net/musca| : |questions|https://answers.launchpad.net/musca| : |suggestions|https://blueprints.launchpad.net/musca| : |customize|#customize| : |settings|#settings| : |howto|#howto| : |changelog|#changelog| : |mailing list|http://mail.aerosuidae.net/mailman/listinfo/musca_aerosuidae.net| : |launchpad|https://launchpad.net/musca| : |0.9.2|#source|

+A simple |dynamic window manager|http://en.wikipedia.org/wiki/Dynamic_window_manager| for X, with features nicked from |ratpoison|http://www.nongnu.org/ratpoison/| and |dwm|http://www.suckless.org/dwm/|+:

+ Musca operates as a |tiling window manager|http://en.wikipedia.org/wiki/Tiling_window_manager| by default.  It uses `manual tiling`, which means the user determines how the screen is divided into non-overlapping `frames`, with no restrictions on layout.  Application windows always fill their assigned frame, with the exception of transient windows and popup dialog boxes which float above their parent application at the appropriate size.  Once visible, applications do not change frames unless so instructed.

+ Since not all applications suit tiling, a more traditional |stacking window manager|http://en.wikipedia.org/wiki/Stacking_window_manager| mode is also available, allowing windows to float at any screen location and overlap.

+ There are no built in status bars, panels, tabs or window decorations to take up screen real estate.  If the user wants any of these things, there are plenty of external applications available to do the job.  Window decoration is limited to a slender border, which is coloured to indicate keyboard focus.

+ |@musca1_small.png right@|musca1.png| Windows are placed in named `groups` which can be used in a similar fashion to virtual desktops.  Groups can be added and removed on the fly, and each group has its own frame layout.

+ The excellent +dmenu+ utility is used to execute commands and launch applications, and it can also act as a window and group switcher.

+ Windows and frames are navigated and focused on any mouse button click, including rolling the wheel, or alternatively driven entirely by the keyboard.  Simple key combinations exist for window switching, group switching, frame control and screen switching.

+ Frames can be `dedicated` to a single application window, preventing new windows usurping said frame.  One frame per group can also be flagged as a `catch-all` so that all new application windows open there.  The frame border colour changes to reflect these modes.

+ |@musca2_small.png right@|musca2.png| Musca has multi-screen support out of the box, and will automatically create groups for every available screen.

+Thanks to ratpoison and dwm authors+.  Musca's code is actually written from scratch, but a lot of useful stuff was gleaned from reading the source code of those two excellent projects.

+Extra kudos to dwm authors for creating dmenu!+  A true sliced-bread-beating invention.

+But `why` do this when there are 17 million other window managers already swanning about the internet?+  Variety is the spice of life?  Actually, +ratpoison+ is very good and I used it for many years; but, I always wanted it to be just a little bit more friendly to the mouse, and just a little bit more informative about frame focus and layout, and just a little bit less `modal` (I can't think of a better way to say that) everywhere.  Sleek little +dwm+ is also great, and while it does focus-follow-mouse and has nice minimal yet informative frame borders, it can't do manual frame layouts and I couldn't add the feature to it satisfactorily (probably my fault).  Other options like +Ion3+ and +Xmonad+ were also fun, but ultimately had fluff of one sort or another.  So, here is +Musca+: the strange offspring of ratpoison and dwm, and very likely only suited to my preferences ;-)  Oh well.

+Why is it named after a star constellation?+  Firstly, so it didn't have "+wm+" in the name.  Secondly, why not?

-- |Controls\controls|

All Musca key bindings start with a modifier key ("M" below), which is bound to +Mod4+ by default.  Mod4 is usually +Super_L+ or the left hand "Windows" key.  This is most convenient as it leaves Ctrl/Alt free for application use.

See |howto|#howto_mod_key| for troubleshooting or changing the Modifier key.

--- Frame Control

Key bindings:

:table bindings
Keys	Action
M+h	split frame in half horizontally to form two frames.
M+v	split frame in half vertically to form two frames.
M+r	remove the current frame and resize others to fill the gap.
M+o	remove all other frames except the current one, resizing it to full screen.
M+u	revert the last frame layout change.
M+d	(toggle) dedicate the current frame to the current app.
M+a	(toggle) set the current frame as a `catch-all`, where all new windows will open.
M+Left	change focus to the frame on the left.
M+Right	change focus to the frame on the right.
M+Up	change focus to the frame above.
M+Down	change focus to the frame below.
M+Ctrl+Left and M+Ctrl+Right	resize current frame horizontally.
M+Ctrl+Up and M+Ctrl+Down	resize current frame vertically.

Musca commands:

:table commands
Command	Action
hsplit <relative\|pixel>	split frame horizontally.
vsplit <relative\|pixel>	split frame vertically.
width <relative\|pixel>	resize frame horizontally.
height <relative\|pixel>	resize frame vertically.
remove	remove the current frame and resize others to fill the gap.
only	remove all other frames except the current one, resizing it to full screen.
dedicate <on\|off>	(toggle) dedicate the current frame to the current app.
catchall <on\|off>	(toggle) set the current frame as a `catch-all`, where all new windows will open.
focus <left\|right\|up\|down> or lfocus rfocus ufocus dfocus	change focus to a frame in the specified direction.
undo	revert the last frame layout change.
resize <left\|right\|up\|down>	resize the current frame in the specified direction.

Relative values can be specified as a percentage or a fraction:

 hsplit 2/3
 hsplit 33%

+hsplit+ and +vsplit+ adjust frame size relative to `itself`.

+width+ and +height+ adjust frame size relative to the `screen size`, less any group padding.

--- |Window Control\controls_window|

Key bindings:

:table bindings
Keys	Action
M+t	launch a terminal.
M+x	launch an app via dmenu.
M+w	switch windows in the current frame, via dmenu.
M+k	politely close the window in the current frame via a close event.  Press again to forcibly kill it.
M+c	cycle a hidden window into the current frame.

Windows automatically receive the keyboard input when they are visible in a focussed frame.

Musca commands:

:table commands
Command	Action
swap <left\|right\|up\|down> or lswap rswap uswap dswap	swap current window with the contents of the frame to the left, right, up and down respectively.
move <name>	move the current window to the group called `name`.
kill	politely close the window in the current frame via a close event.  Press again to forcibly kill it.
cycle	cycle a hidden window into the current frame.
raise <number\|title>	raise and focus a window in the current group by number (order opened) or title.
manage <on\|off> <name>	(toggle) set whether the window class called `name` is managed or ignored.

--- Group Control

Key bindings:

:table bindings
Keys	Action
M+g	switch groups via dmenu.
M+PageUp	switch to the previous group.  (PageUp == X11 Prior)
M+PageDn	switch to the next group.  (PageDn == X11 Next)
M+s	(toggle) switch the current group between `tiling` and `stacking` window modes.

Musca commands:

:table commands
Command	Action
add <name>	create a new group called `name`, and switch to it.
drop <name>	delete a group by `name`.
name <name>	rename the current group.
dump <file>	export a description (group name and frame layout) of the current group to `file`.
load <file>	import a description from `file` into the current group.
use <name>	switch to the group called `name`.
stack <on\|off>	(toggle) switch the current group between `tiling` and `stacking` window modes.

In `stacking` mode, Windows can be moved using +M+Mouse1+, and resized using +M+Mouse3+.  |More detail|#howto_stacking|.

--- Screen Control

Key bindings:

:table bindings
Keys	Action
M+Tab	switch to the next available screen.

Musca Commands:

:table commands
Command	Action
screen <number>	switch to screen `number`.  This is zero based, and should match the order in which screens are defined in {xorg.conf}.

--- |General Controls\controls_general|

Key bindings:

:table bindings
Keys	Action
M+m	Run a Musca command via dmenu.

Musca commands:

:table commands
Command	Action
exec <command>	execute as shell command.
pad <left> <right> <top> <bottom>	set the current group screen padding in pixels.
bind <on\|off> <Modifier>+<Key> <command>	bind a Musca command to a key combination with `on`, and remove it again with `off`.  The `command` argument is only need for `on`.
set <setting> <value>	set a Musca variable.  See |settings|#settings| for a list of variable names.
quit	exit Musca.

-- |Source\source|

A Musca bazaar repository is available on |launchpad|https://launchpad.net/musca|.  It should always build, but it is a development tree so it may not be stable.

This is the latest dated snapshot considered stable: |musca-0.9.2.tgz|musca-0.9.2.tgz|

--- Build Dependencies:

+ Xlib
+ GNU C Library
+ make
+ gcc

Install the above for your system, grab the source, and run +make+.  Copy the resulting {musca} binary into your {$PATH} somewhere.

--- Runtime Dependencies:

+ dmenu

-- |Author\author|

Feel free to email feedback:

sean dot pringle at gmail dot com

-- |Customize\customize|

Most |settings|#settings| can be changed on the fly using Musca commands, and applied each time using the startup file option.  Alternatively, to change the default settings, modify {config.h} and recompile.

-- |Settings\settings|

Musca has a list of settings that can be altered on the fly using the +set <name> <value>+ command:

 set border_focus Orange

:table musca_settings
Name	Default	Description
border_focus	Blue	Border colour for focused frames in tiling mode, and focused windows in stacking mode.
border_unfocus	Dim Gray	Border colour for unfocused frames in tiling mode, and unfocused windows in stacking mode.
border_dedicate_focus	Red	Border colour for focused `dedicated` frames in tiling mode.
border_dedicate_unfocus	Dark Red	Border colour for unfocused `dedicated` frames in tiling mode.
border_catchall_focus	Green	Border colour for focused `catchall` frames in tiling mode.
border_catchall_unfocus	Dark Green	Border colour for unfocused `catchall` frames in tiling mode.
frame_min_wh	100	Minimum width and height in pixels of frames and managed windows.
frame_resize	20	Size in pixels of a frame resize step.  Setting this smaller will make resizing operations smoother, but also slower and increase load.
startup	.musca_start	(optional) Path to a file containing Musca commands to run at start up.  The default setting is relative to the working directory; ie, Musca will use $HOME/.musca_start `only if Musca is started from $HOME`, which is the usual method for login managers.  The file must contain one command per line.  Lines starting with hash +#+ are comments and blank lines are acceptable.
dmenu	{dmenu -i -b}	Command to run to launch +dmenu+ along with any customize appearance arguments.  This can be replaced by another launcher so long as it accepts a list of +\\n+ terminated items on stdin and returns a single line on stdout.
switch_window	{xargs -I name $MUSCA -c "raise name"}	The command to run once the user has selected a window number and name from +dmenu+.
switch_group	{xargs -I name $MUSCA -c "use name"}	The command to run once the user has selected a group name from +dmenu+.
run_musca_command	{xargs -I command $MUSCA -c "command"}	The command to run when the user has entered a Musca command via +dmenu+.
run_shell_command	{xargs -I command $MUSCA -c "exec command"}	The command to run when the user has entered a shell command via +dmenu+.
notify	{echo %s}	The command to run to send the user a message.  By default Musca just writes to stdout.
stack_mouse_modifier	Mod4	The modifier key to use in `stacking` mode, along with mouse buttons 1 and 3, to move and resize windows respectively.

-- |Howto\howto|

+ |Start Musca|#howto_start|
+ |Use multi-windowed apps like the Gimp|#howto_multi_window_apps|
+ |Change or troubleshoot the Modifier key|#howto_mod_key|
+ |Change the default key combinations|#howto_key_combos|
+ |Change the default border colours|#howto_borders|
+ |Run a system tray|#howto_tray|
+ |Set a desktop background|#howto_background|
+ |Make Musca ignore windows|#howto_ignore|
+ |Use a startup config file|#howto_startup|
+ |Control Musca externally|#howto_control|
+ |Get a list of windows in the current group|#howto_windows|
+ |Use `stacking` window management mode|#howto_stacking|

--- |Start Musca\howto_start|

---- Using startx

Launch it from your +.xinitrc+ file, using +startx+:

 exec /path/to/musca

---- Using a login manager like GDM or KDM

Create /usr/share/xsessions/musca.desktop, and select the Musca session at login:

 [Desktop Entry]
 Encoding=UTF-8
 Type=XSession
 Exec=/path/to/musca
 Name=musca

---- For debugging

Start X with a single xterm running, and launch Musca manually from the xterm, so you can see stdout/stderr (which is where any errors from your dmenu commands will appear).  So in {.xinitrc}:

 exec xterm

--- |Use multi-windowed apps like the Gimp\howto_multi_window_apps|

---- In Tiling Mode

People seem to think this is a huge problem with tiling window managers, but it really is not, particularly in Musca where any old tiling layout can be used and nothing moves around once visible.  |See|musca2.png|?

Start with a single full screen frame and a few small frames off to one side.  Switch to and dedicate the largest frame with +M+d+.  Open the app in the largest frame and the first (hopefully primary) app window will open there, while secondary windows distribute themselves among the smaller frames.  Adjust the number and layout of frames as required for the app in question.  Use the |swap|#controls_window| commands to shift windows around if needs be.

Afterward it may be worthwhile dedicating the smaller frames to ensure they only ever hold the dialog windows you want there, or just set the largest frame as a catch-all to achieve the same effect.

Note that some apps like OpenOffice have windows which are normal dialogs, but they automatically unmap themselves when the primary window is not focussed.  These may flick in and out of existence in the smaller frames.  Not much we can do about it, except use OOo full screen and dock everything with Ctrl+Shift+F10, or use stacking mode.

---- In Stacking Mode

Create a new window group and set it to `stacking` mode with +M+s+, then use the multi-windowed app just as you would in any stacking window manager.  See how the |stacking controls differ|#howto_stacking|.

--- |Change or troubleshoot the Modifier key\howto_mod_key|

Changing the Modifier key is possible by modifying {config.h} and recompiling.  Valid modifier keys are listed in {modmasks[]}, and default key combinations are in {keymaps[]}.  Alternatively, to prevent the need to recompile, you can customize key bindings on the fly using the |+bind+ command|#controls_general|.

Mod4 is commonly bound to X11's +Super_L+ key, which is usually the left Windows key on Linux PCs with a US or UK keyboard layout.  If you're on a different system and the default Modifier key does not work, then establish where mod4 (if it exists!) is pointing by using +xmodmap+:

 $ xmodmap | grep mod4
 mod4        Super_L (0x7f),  Hyper_L (0x80)

Or run the +xev+ utility, press the left Win key, and watch xev's standard output while you do it.  Something like this should appear:

 KeyRelease event, serial 27, synthetic NO, window 0xe00002,
    root 0x259, subw 0x0, time 672433, (417,298), root:(418,299),
    state 0x40, keycode 115 (keysym 0xffeb, Super_L), same_screen YES,
    XLookupString gives 0 bytes:
    XFilterEvent returns: False

Using these two tools, find a suitable Modifier key for your system.

--- |Change the default key combinations\howto_key_combos|

Look at the {keymaps[]} structure in {config.h}.  X11 key names are in X11/keysymdef.h; just remove the 'XK_' from the constant definitions to get the names.  Either modify {keymaps{}} and recompile, or apply key bindings on the fly in {.musca_start} using the |+bind+ command|#controls_general|.

--- |Change the default border colours\howto_borders|

Look at the +border_...+ fields in {settings[]} in {config.h}.  X11 named colours are on |http://en.wikipedia.org/wiki/X11_color_names|http://en.wikipedia.org/wiki/X11_color_names|.  Either modify {settings[]} and recompile, or apply key bindings on the fly in {.musca_start} using the |+set+ command|#controls_general|.

--- |Run a system tray\howto_tray|

Use the +trayer+ utlity and set padding on a window group so as not to obscure it.  For example:

 #!/bin/bash
 trayer --edge bottom --align center --height 32 --SetDockType true --SetPartialStrut false \
  --transparent true --alpha 255 --tint 0x00ff00 --distance 0 --expand true >.trayer.log 2>&1

Whatever system tray application you choose will need to have its WM_CLASS |unmanaged|#howto_ignore|.  Trayer is already unmanaged by default.

--- |Set a desktop background\howto_background|

Musca doesn't touch the root window and frames are transparent, so go use something line +xsetroot+ or +xv+ or +imagemagick+ to set the background.  For example, with imagemagick:

 $ display -window root <path_to_image>

--- |Make Musca ignore windows\howto_ignore|

In {config.h} there is an {unmanaged_windows[]} list of WM_CLASS names:

 char +unmanaged_windows[] = { "trayer", "Xmessage", "Conky" };

Check out the +xprop+ utility to find class names.  Either change {unmanaged_windows[]} and recompile, or do on the fly in {.musca_start} with the |+manage+ command|#controls_window|.  Note that any +manage+ setting only takes effect for `subsequently` opened windows.

--- |Use a startup config file\howto_startup|

Set the `startup` setting in {config.h} to point to a text file of your choice (default is {.musca_start}).  It should contain Musca commands (exactly as would be launched with +M+m+), one per line.  Any comments must be on separate lines starting with hash +#+.  Blank lines are acceptable.  For example:

 manage off trayer
 manage off Conky

 screen 1
 name bling
 pad 0 0 0 32
 exec trayer
 exec conky

 screen 0
 add mail
 add net
 add work
 use mail
 exec firefox gmail.com
 exec evolution
 hsplit 1/2

 set notify notify-send -t 3000 Musca "%s"

Note that lanuching apps from the startup file is OK, but can be of limited use if you want to do it in more than one group.  The +exec+ command runs asynchronously, and if apps are slow to create their windows, they may not necessarily appear in the group you expect.  In this case, try launching apps from {.xinitrc} and just moving them around here.

--- |Control Musca externally\howto_control|

Musca commands can be dispatched from an external script by calling Musca with the {-c <command>} command line argument:

 musca -c "hsplit 1/3"

In this case, the Musca binary will try to connect to an already running instance of Musca, deliver the command, and return once the command has executed.

--- |Get a list of windows in the current group\howto_windows|

Use the group +dump <file>+ command and extract lines starting with the word `window`.  Each line is a series of tab delimited fields in this order:

+ Number in the current group.
+ Class name.
+ Title.

For example:

 #!/bin/bash
 file=/tmp/group.txt
 musca -c "dump $file" && cat $file | grep -r '^window' | awk -F '\t' '{print "id: " $2 " class: " $3 " title: " $4}'

Mould into whatever form suits you.

--- |Use `stacking` window management mode\howto_stacking|

Stacking window management mode is available at the window group level, on a group by group basis.  Select the group you wish to make stacking, and press +M+s+ or run the command +stack on+.  Any frames in the group will disapear.  Other groups will not be affected.

Floating windows can be moved using +M+Mouse1+ -- that is: hold down the modifier key and click the left mouse button on the window -- and dragging the mouse.  Floating windows can be resized using +M+Mouse3+ in the same fashion.  Click-to-focus still works.

Most of the frame manipulation related key combinations and commands are disabled in stacking mode.

No, there is no way to float specific windows while in tiling mode.

To switch the group back to tiling mode, press +M+f+ again or run the command +stack off+.  The group frames will be recreated as they were before the mode change.

-- |+Changelog+\changelog|

+ |0.9.2|#changelog_0.9.2| (|tgz|musca-0.9.2.tgz|)
+ |0.9.1|#changelog_0.9.1| (|tgz|musca-0.9.1.tgz|)
+ |0.9|#changelog_0.9| (|tgz|musca-0.9.tgz|)
+ |20090313|#changelog_20090313| (|tgz|musca_20090313.tgz|)
+ |20090312a|#changelog_20090312a| (|tgz|musca_20090312a.tgz|)
+ |20090312|#changelog_20090312| (|tgz|musca_20090312.tgz|)
+ |20090311|#changelog_20090311| (|tgz|musca_20090311.tgz|)
+ |20090310|#changelog_20090310| (|tgz|musca_20090310.tgz|)
+ |20090309|#changelog_20090309| (|tgz|musca_20090309.tgz|)
+ |20090305|#changelog_20090305| (|tgz|musca_20090305.tgz|)
+ |20090304|#changelog_20090304| (|tgz|musca_20090304.tgz|)
+ |20090303|#changelog_20090303| (|tgz|musca_20090303.tgz|)
+ |20090302|#changelog_20090302| (|tgz|musca_20090302.tgz|)
+ |20090301|#changelog_20090301| (|tgz|musca_20090301.tgz|)

--- |0.9.2\changelog_0.9.2|

+ Tuning: politely check PResizeInc for apps in both stacking and tiling modes.
+ Tuning: changed window resize and drag in stacking mode to use a window outline, to better suit slow video.

--- |0.9.1\changelog_0.9.1|

+ Tuning: prevent parent windows from hiding when transients popup.
+ Bugfix: correctly resize bound keys structure when >31 combinations are bound.

--- |0.9\changelog_0.9|

No difference to |20090313|#changelog_20090313| release, expect that we are starting a more traditional versioning numbering scheme to better suit distro packaging practices.  We're starting at 0.9 because Musca now has all the major features I wanted when starting the project, and bugs seem minimal, but we still need to do extended stability testing.  There is a feature freeze now in effect.

`+Note+ There was some discussion via email that this should be 1.0, and the 0.9 tarball was initially pushed as 1.0.  But after coffee, I think being feature complete and not having many bugs reported doesn't really justify that with a young code base.  So, 0.9 it is.`

--- |20090313\changelog_20090313|

+ Windows now remember their floating position across stacking/tiling mode switches.
+ Bugfix: better MotionNotify co-ordinate checking when resizing in stacking mode.
+ Improved window stacking behavior in relation to unmapped windows, and reduced focus flicker of groups in stacking mode.
+ Improved error checking converting colour names to pixel values for borders.
+ Use {execlp()} instead of {execl()} for launching shell commands with +exec+, to mimic shell parsing and $PATH checking for commands without a full path.
+ Improved key grabbing to prevent blocking some key combinations from the application when we don't need them.

--- |20090312a\changelog_20090312a|

+ |Bugfix|https://bugs.launchpad.net/musca/+bug/341219|: using SIG_IGN for SIGCHLD exits annoys +dbus+ autolaunch, so handle it normally with waitpid.
+ Added additional error check to +bind+ command, to ensure the supplied key symbol is valid.  Previously, it only verified key modifiers.

--- |20090312\changelog_20090312|

+ Cleaned up {config.h}.
+ Replaced various constants with a simple table {settings[]} holding variables that can be set dynamically.
+ Converted {key_callbacks[]} to {keymaps[]} to simply map key strokes to Musca command strings.
+ Added commands: resize, raise, bind, switch, command, shell, set.
+ Added code to filter out NumLock and CapsLock from our key commands (too easy to leave one turned on and disable stuff). Thanks to Nikita Kanounnikov for pointing this bug out.

--- |20090311\changelog_20090311|

+ Tweaked Musca's dmenu usage to execute in a child process.  This should help with the reports made by some people where both dmenu and Musca freeze when the mouse is clicked, or a window opens, while dmenu is running.  Now neither event affects dmenu.
+ Added an {XGrabKeyboard()} check during the Musca startup process.  If it fails, it will throw a warning to {stderr} like:  `Could not temporarily grab keyboard. Something might be blocking key strokes.`  This might help with |this bug|https://bugs.launchpad.net/musca/+bug/336473|.
+ Added the +raise <number\|title>+ command, to raise a window.

--- |20090310\changelog_20090310|

+ Added option to switch window groups between tiling and stacking modes.

--- |20090309\changelog_20090309|

+ Added commands: remove, kill, cycle, only, focus, dedicate, catchall, undo, dump, load, use, exec, swap, screen, manage.  Mnay of these duplicate hot keys, but may be useful to external scripts.
+ Added ability to dump and load group frame layouts to file with +dump <file>+ and +load <file>+ commands.
+ Added the option of a startup script (which needs to be a list of Musca commands), defined by the {STARTUP} definition in {config.h}.
+ Added frame layout `undo` tracking, so that up to 32 frame layout changes per group can be rolled back.
+ Added client command interface for external control by calling {musca -c <command>}
+ Rearranged Musca startup routine slightly to isolate |this bug|https://bugs.launchpad.net/musca/+bug/336473|.
+ Applied a {FOR_RING()} macro to automate looping about head/group/frame/client doubly-linked rings.
+ Improved `click-to-focus` behavior to reduce frame screen flicker.
+ Added restrictions to ensure transient windows follow if their parent is moved between groups.
+ Added logic to prevent a parent window being cycled into another frame when a transient takes focus above it.
+ Added logic to ensure a parent window regains focus in the same frame with a transient window exits.
+ Migrated old {client->kill_event_sent} to a {client->flags} bit.
+ Added ability to manage and unmanage window classes on the fly.
+ Changed {commands[]} struct in {config.h} to a list of command pointers, rather than one long hard to read \\n delimited string.

--- |20090305\changelog_20090305|

---- misc stuff

+ Added TERMINAL to config.h to point to the perferred console app, defaulting to xterm.
+ Added NOTIFY to config.h to point to an external notification app, like {dzen} or {notify-send}.
+ Added example custom launcher functions to config.h, with M+t activated to launch a terminal.
+ Convert {unmananged_windows} to use window class names instead of titles.
+ Reduced default verbosity when logging.

--- |20090304\changelog_20090304|

---- bug fixes

+ Stop frames on an unfocused screen taking the keyboard focus when their client window exited.
+ Fix possible buffer overflow, due to an incorrect {realloc()}, when creating the list of window titles for dmenu.

--- |20090303\changelog_20090303|

---- `width` and `height` commands

Added +width+ and +height+ commands, and {com_frame_size()}, to resize a frame size relative to the screen size or to a specific pixel value.

--- |20090302\changelog_20090302|

---- move windows between groups

Added the +move <group_name>+ command, and {com_window_to_group()}, to move the active window to another group.

---- define a `catch-all` frame

Added +M+a+ key combination, and {frame_catchall()}, to define a frame per group in which +all+ new non-transient windows will open.

--- |20090301\changelog_20090301|

---- key_modifiers

Added {key_modifiers[]} struct to config.h.  This lists the modifier key combinations we're interested in.  Any modifier used in {key_callbacks[]} must also appear in {key_modifiers[]}.

---- key combination logging

Added key combination logging.  Each matched modifier+key combination is logged, eg, a hsplit:

 keypress handling key: Mod4 h

..and each unmatched modifier+key (where modifier is one we're interested in) is logged:

 keypress unhandled key: Mod4 q

This makes it easy to find out X11 key names when modifying {key_callbacks[]}.
-------------------------------------------------------------------
*** Sonstiges
- seit 2009 nichtmehr weiterentwickelt, nur noch Communitypatches
Herbstluft wm kommt dem am nächsten*
** ratpoison :rejected:
- wird nicht mehr weiterentwickelt

** sawfish :rejected:
- war früher mal bei gnome dabei, und die offizielle entwicklung war
  auch mal gestoppt und wird jetzt durch community betrieben

** dwm :rejected:
- sieht sehr schnell aus und scheint auch recht zügig
  on-the-fly neue aufteilung bilden zu können
- zum neukonfigurieren source neu übersetzen?!
- benutzt tags für die Fenster
- wirbt damit, kaum Features zu haben o.O
- keine config-dateien!!
  - das Programm ist aber sehr klein, so dass das überschaubar ist
- da keine jedes mal neu kompilieren kann ein flexibles
  installieren von erweiterungen wohl vergessen werden
  und eingebaut ist dann auch nicht allzu viel

** monsterteil :rejected:
- hardcore kürzungen
** snapswm :rejected:
- sieht an und für sich sauber gemacht aus
aber wieder alles änderungen in dem header => ficken sie sich
** Ion :timefiller:
** StumpWm :timefiller:
** trition
** pekwm

* Python
** Python (in Emacs)
*** Rope
Rope dient dem Refactoring (umbenenenen, grundlegend semantik in
Projekt erkennen und son Zeug). Auch anderer höherer Kram wie das
generieren neuer Funktionen usw. sind möglich. Meine fresse, teilweise
echt geile scheiße dabei.
*** Ropemacs
Bietet interaktive Schnittstellen in Emacs um Rope-refactorings
durchzuführen. Greift dabei auf Pymacs zurück, mit welchem dann
Ropemode Schnittstellen verwendet werden, die dann Rope benutzen.
Ist selbst ebenfalls nur Python => benötigt selbst auch schon
Pymacs.
*** Pymacs
Stellt die Verbindung zwischen Python und ELisp her, in dem die
wichtigsten Funktionalitäten in Wrapper gepackt werden
*** Ropemode
Eine Pythonbibliothek, die Schnittstellen zu Rope liefert (logischerweise
über Python)
** Python Generell
*** Skriptansatz Automatisierung Ilias
import re
import mechanize
br = mechanize.Browser()
br.open("https://ilias.uni-marburg.de")
#br.retrieve()
print br.select_form(name="formlogin")
br["username"] = "|||username|||"
br["password"] = "|||passwort|||"
responsex = br.submit()
for link in br.links(url_regex="497203[^\n]*cmd=[^1]"):
    if link.text == "Elementare Stochastik":
        print link
        br.follow_link(link)
#br.follow_link("https://ilias.uni-marburg.de/repository.php?ref_id=506449&cmd=view")
br.open("https://ilias.uni-marburg.de/repository.php?ref_id=506449&cmd=view")
br.geturl()
br.response().get_data()
print "check1"
for link in br.links(url_regex="file"):
    if not re.match("Symbol Datei", link.text ):
        print link.text
        print "----"
print "check2"

*** Filemanagement
# The built-in function `open` opens a file and returns a file object.

# Read mode opens a file for reading only.
try:
f = open("file.txt", "r")
try:
# Read the entire contents of a file at once.
string = f.read()
# OR read one line at a time.
line = f.readline()
# OR read all the lines into a list.
lines = f.readlines()
finally:
f.close()
except IOError:
pass


# Write mode creates a new file or overwrites the existing content of the file.
# Write mode will _always_ destroy the existing contents of a file.
try:
# This will create a new file or **overwrite an existing file**.
f = open("file.txt", "w")
try:
f.write('blah') # Write a string to a file
f.writelines(lines) # Write a sequence of strings to a file
finally:
f.close()
except IOError:
pass

# Append mode adds to the existing content, e.g. for keeping a log file. Append
# mode will _never_ harm the existing contents of a file.
try:
# This tries to open an existing file but creates a new file if necessary.
logfile = open("log.txt", "a")
try:
logfile.write('log log log')
finally:
logfile.close()
except IOError:
pass

# There is also r+ (read and write) mode.



* Shortcutliste
- C-c C-x C-i :: Clock in
- C-c C-x C-o :: Clock out
- C-c C-x C-c :: cancel Clock
- C-c C-t     :: toggle todo state
- C-c C-x C-r :: Zusammenfassung der Clocks von Substree
- C-u C-c C-x C-i     :: switch Task (nahtloser Wechsel)
- C-u C-u C-c C-x C-i :: Clock in, mark as default (überall reclock in usw.)
- C-c C-x C-d :: An jedem Tree jeweils die Zeit anzeigen
- C-c C-c     :: Update für Ding unter Cursor
- C-c C-x ;   :: Set (und start) Timer
- C-c C-x e   :: set estimated effort time

- C-c C-u     :: Sprung zum Header
- C-j/C-k     :: auf einer Ebene bewegen
- C-ö t       :: org tree to indirect buffer
- C-c C-x C-l :: preview latex fragment (C-c C-c für undo)
- C-ö D       :: display inline images
- g ;         :: springe zu letzter veränderung

- C-n,p       :: Evil Extension, zurück
- C-x C-n,p   :: Evil complete line, zurück
- M-/         :: Hippie expand
- C-ä c       :: mögliche Completions anzeigen
- C-ä w d/D   :: dedicate/undedicate window

- C-x * c     :: öffnet calculator
		 => eingabe in postfix/ergebnis paste mit y/close mit q

- C-c b       :: view Buffer other window
- C-x f       :: find file other window
- C-ö b       :: display buffer
- C-ö f       :: display file
- C-ö n/r     :: next/prev Empty Line
- C-{/}       :: next/prev regex
- C-ö g/G     :: Vertikalsprung hoch/runter

- C-ä n       :: Neues Snippet
- C-ä q       :: Snippet Buffer laden
- C-ä f       :: neues Snippet aus Content
- C-ä g       :: Platzhalter erstellen (für Oneshot Snippet)
- C-ä h       :: Oneshot Snippet (erstellen oder einsetzen)

- C-ä k/K     :: encrypt/decrypt region
- C-ä s       :: Screenshot erstellen und einsetzen
- C-ö d       :: doc-view-mode
- C-ä l       :: konvertiere zu Latex
- C-ä w s     :: Session speichern
- C-ä w r     :: Session laden
- C-ä w u     :: Winner undo
- M-ä         :: Cursor in Fenster springen lassen

- M-m         :: Helm: M-a = alle markieren
- C-ö o       :: Helm Occur (akt. Buffer)
- M-h M-x     :: Helm - M-x -> History usw.
- C-ö s       :: Helm - do - grep
- C-g / C-t 0 :: Popwin Fenster schließen
- C-t         :: Popwin Keymap:
- b           :: Popup Buffer
- l           :: Popup Last Buffer
- s           :: stick Popup Window
- spc         :: select Popup Window
- e           :: show messages
- C-t C-u ... :: zwingt das Fenster zum öffnen in popwin
- C-ö k       :: helm show killring
- C-ö h       :: helm apropos
- C-ö i       :: Imenu (Header Übersicht und Sprung)

- C-ö e n     :: emms-next
- C-ö e p     :: emms-previous
- C-ö e P     :: emms-pause
- C-ö e s     :: emms-shuffle
- C-ö e r     :: emms-repeat
- C-ö e f     :: emms-add-find
- C-ö e d     :: emms-add-directory-tree
- C-ö e l     :: emms-playlist-mode-go

- C-x z z...  :: repeat last emacs action
- C-!         :: evil-normale-state (force)
. @@          :: repeat last macro

- C-ö m l     :: magit pull
- C-ö m h     :: magit push
- C-ö m s     :: magit status
    s         :: stage
    u         :: unstage
    c C-c C-c :: commit, - absenden
    ll        :: log
