;#+STARTUP: content
* Projekte
** TODO Kleinkram
*** NEXT das system wiederfinden, mit der man eine sicht auf 2 Buffer verteilen konnte
  [[file:~/Zettelkasten/softwaretechnik.org::*a.][a.]]
  Entered on [2013-01-25 Fr 18:42]
*** TODO emacs-server ohne fenster starten und danach laufen lassen
*** TODO frame nach schließen des letzten fensters schließen
*** TODO hide boring buffers installieren
*** TODO zeilenumbruch nach header ohne punkt in latex
*** TODO config für tag-anfang / ende in emacs suchen und umstellen
*** TODO clocks automatisch für diese zeitspanne generieren lassen
*** TODO autosave emacs plugin installieren und testen
** TODO elisp
*** NEXT elementare Problemstellungen in elisp mit snippets sammeln
*** TODO popwin nach hilfreichen fenstermodifikationen durchsuchen
*** TODO snippet für regex skipping zusammenstellen
** TODO firefox
*** TODO fehlermeldung beim start prüfen und in den dateien fixen, ggb. .gitignore usw
*** NEXT pdf in firefox automatisch starten lassen (siehe da wo auch protocol eingestellt wurde)
*** TODO google pentadactyl yank to clipboard
*** TODO firefox schließen, wenn der letzte tab geschlossen wurde
** TODO Emacs Config Aufräumen
*** DONE überflüssige keymapping dateien entfernen
    - State "DONE"       from "NEXT"       [2013-01-23 Mi 13:21]
*** DONE nicht mehr benutzte dateien in .emacs.d löschen
    - State "DONE"       from "TODO"       [2013-01-23 Mi 13:21]
*** TODO eigene und custom funktionen in die emacs_config integrieren
*** DONE org babel alles laden lassen
    - State "DONE"       from "NEXT"       [2013-01-23 Mi 20:27]
*** DONE alle shortcuts in .emacs zusammenfassen
    - State "DONE"       from "TODO"       [2013-01-24 Do 15:47]
*** DONE funktionen in .emacs auslagern
    CLOCK: [2013-01-14 Mo 19:59]--[2013-01-14 Mo 20:11] =>  0:12
*** NEXT unnötige keybindings entfernen
*** DONE in bytecompiling einlesen
*** DONE alles bytecompilen
** TODO Org-Mode Bilder
*** DONE prüfen ob die latex plugins was taugen
    - State "DONE"       from "NEXT"       [2013-01-31 Do 14:24]
*** NEXT Möglichkeiten prüfen um informationen/texte einem konkreten Header zuzuordnen
*** TODO my-make-latex-2 zusammenstellen
**** bisheriger beispielcode
(defun blatest () (interactive)
  (let (ov)
    (setq ov (make-overlay 20 30))
    (overlay-put ov 'display (create-image "~/test.png"))))
*** TODO Möglichkeiten sammeln, zum zeilenweisen auslesen und splitten bei trennzeichene
*** TODO beim link erstellen eben jene information in extra ast unterbringen
*** TODO 2. löschenroutine, welche nach dem löschen eben diesen wert wieder ausliest
*** TODO bilder im org - mode in separaten Ordner verschieben
*** DONE Funktion bzw. Regex um links und die darin enthaltenen Bilder zu identifizieren
    \\[\\[\\(.*\\)\\]\\]  catched die links
    search-forward-regexp such entsprechend
    matched-string holt die einzelnen werte der letzten suche 
       (parameter 1 für die erste gruppe) oder 0 für ganzen string
    (goto-char (match-end 0))  um anfang und ende von link zu erreichen
    
(defun my-org-extract-link ()
  "Extract the link location at point and put it on the killring."
  (interactive)
  (when (org-in-regexp org-bracket-link-regexp 1)
    (kill-new (org-link-unescape (org-match-string-no-properties 1)))))

*** DONE Deletion Funktion für das Bild unter dem Cursor hinzufügen, falls slice, dann alle anderen slices finden
*** DONE Möglichkeiten nachträgliches resizen der Bilder im Org-Mode eruieren
    - macht innerhalb vom Orgmode bisher einfach keinen Sinn
*** DONE prüfen ob Bilder mit Linktext immernoch dargestellt werden, falls nicht, konfigurieren
*** DONE latex code in die linkbeschreibung pasten, klammern entsprechend entwerten
*** DONE extra Fenster bei Latexumwandlung unterdrücken; google save-excursion
*** DONE iimage bibliothek o.ä. code raussuchen und auf anpassparkeit prüfen
*** DONE anforderungen an eigenen Modus sammeln
*** DONE entsprechenden modus entwickeln ;image slicing
*** TODO der transparente bereich auf den draufgemappt wird (python) auf mindestgröße setzen
** TODO Musik Player Einrichten
*** DONE google awesome-wm automount Ziel: Festplatte unter festem Namen mounten
    - State "DONE"       from "NEXT"       [2013-01-22 Di 19:50]
*** NEXT Playlists zusammenstellen und in einem Ordner verlinken
*** TODO Org Mode links für emms möglichkeit suchen
*** TODO alternative: Helm (/Anything) emms suchen und benutzen
** TODO Tags							    :PROJECT:
*** DONE etags installieren
*** NEXT google: wie können tags zu den unterschiedlichen dokumentarten generiert werden
*** TODO google: welche navigations und sammelmöglichkeiten gibt es?
*** TODO Shortcuts für die Tags entsprechend legen
** TODO Capturing						    :PROJECT:
*** TODO welche Captures ;-Templates; würden noch Sinn machen? Broweser/Client
*** TODO prüfen ob zur commands.tex datei gecaptured werden kann
*** NEXT raussuchen wie firefox links speichert, und capture schreiben um link für aktuelle Seite an to-read zu senden
*** DONE schnellere Shortcuts für Captures 
*** TODO Captures entsprechend implementieren
** TODO Shortcuts						    :PROJECT:
   :LOGBOOK:
   CLOCK: [2013-01-25 Fr 21:23]--[2013-01-25 Fr 21:57] =>  0:34
   :END:
*** TODO welche Snippets machen noch Sinn? -> einbauen
*** TODO einzelnes zeichen einsetzen und direkt wieder normal-mode
*** TODO my-keys-minor-mode und evil-normal mode zusammen legen
  [[file:~/.emacs.d/emacs_config.org::*Minormode][Minormode]]
  Entered on [2013-01-24 Do 23:49]
*** TODO org-mode Shortcuts neu einstellen
*** TODO displaybuffer testen, und customize prüfen, ob fenster gesplittet werden
*** DONE verschiedene StandardClocks einsetzen
    - State "DONE"       from "NEXT"       [2013-01-25 Fr 21:58]
*** DONE shortcuts für scrolling in pentadactyl ummappen
*** DONE verschieben/retaggen von Fenstern in awesom wm
*** DONE mehr Tasten auf den Modalen Vim Modus setzen
*** DONE Firefox Zwang auf web lösen
*** DONE completion shortcuts bequemer machen			  :shortcuts:
*** DONE Orte mit -letzten- veränderungen oder sowas durchgehen; cyclen - plural
*** DONE shortcut für zuletzt benutztes bookmark		  :shortcuts:
*** DONE Shortcut Header Sprung besser legen			   :shortcut:
*** DONE Emacs wiederholung braucht ein besseres shortcut; z schwer zu finden :shortcut:
*** DONE zyklisches Pasten von Emacs aus Killring		  :shortcuts:
*** DONE shortcuts für erstellen von tmp autonamed bookmark und cyclen; in buffer :shortcuts:
*** NEXT Shortcut Timer in Capture installieren
*** DONE besseres shortcut für kill-window in awesome
    - State "DONE"       from "TODO"       [2013-01-27 So 23:35]
  [[eshell:*eshell*:cd%20Zettelkasten/][cd Zettelkasten/]]
  Entered on [2013-01-25 Fr 18:32]
*** TODO Shortcut um mehrere Einträge bei magit auf einmal zu stagen oder zu markieren
*** TODO next / prev buffer shortcuts googlen / einrichten (siehe burry buffer)
** TODO Sprungmarken						    :PROJECT:
*** TODO Liste mit Features von Bookmark+ anfertigen
*** NEXT markierung und/oder anzeige für evil marks im Dokument anzeige ;goggle
nicht mehr zeit verschwenden, als unbedingt nötig, da die evil marks in jedem fall auch
durch autobookmarks ersetzt werden könnten
google: emacs+evil+show+mark 
*** TODO Shortcuts für next / prev buffer setzen
** TODO [#A] TodoListe optimieren				    :PROJECT:
*** NEXT Brainstorming, was Standardmäßig geöffnet und was geschlossen sein soll
*** TODO autostarts neu zuteilen ;source blöcke usw.
*** TODO übersicht zum aufbau von agenda modi zusammenstellen
*** TODO face von high-priority items besondrs hervorheben
*** TODO autogen nochmal restarten
*** TODO richtiger alarm für estimated time
*** DONE todo states und faces aus "your life in plaintext"
    - State "DONE"       from "NEXT"       [2013-01-23 Mi 14:35]
*** TODO workflow für habits / scheduled tasks ausarbeiten
** TODO Latex Mode						    :PROJECT:
*** DONE Cdlatex Paket suchen und installieren
    ist total sinnlos, yasnippet kann das alles auch. Statt dessen eher mal nach math mode suchen
*** DONE testen in wie fern schnelles suchen und finden von Symbolen möglich ist
    - mit latex math mode lässt sich mit backtick
      und dann nem normalen Zeichen das latex äquivalent bilden
    z.B. * wird zu \times
    - für andere Zeichen gibt es helm-c-insert-latex
*** NEXT testen wie weit auto completion von viel genutzen symbolen -Rightarrow...- glatt läuft
   - man könnte natürlich yasnippet benutzen 
   - oder man schreibt eigene latex kürzel
*** TODO math mode und insert latex in workflow einbinden
*** TODO Commands mit Sonderzeichen einbauen
    test, \ vor die einzelnen sonderzeichen zu schreiben
*** TODO Syntaxhighlighting latex babel googlen
*** TODO babel direkt eine pdf datei generieren lassen
*** TODO prüfen in wie fern nun das laden einer Masterdatei möglich ist
*** TODO prüfen ob und wie babel nur den aktuellen block tangled
*** TODO einrückung der zettelblöcke korrigieren
*** TODO gegebenenfalls weitere Completion Methoden einsetzen
** TODO file accessability
*** NEXT übersicht zu den helm sources anfertigen
*** TODO recentf files verlängern (auf 20 oder so)
** TODO Git							    :PROJECT:
*** DONE die 3 Grundmerges finden ;a / b / beide
*** NEXT magit: commit und push?
** TODO effizienteres Suchen					    :PROJECT:
*** NEXT Suchmaschine für Quellcodes
*** TODO alternative rc.lua suchen
*** TODO alternative .emacs suchen
*** TODO alternativen zu google prüfen / bessere Befehle sammeln
** TODO awesome wm						    :PROJECT:
*** NEXT Titlebar Awesome Wm googlen. Ziel: Titlebars in bestimmten Tags mit Floating standard, aktivieren.
*** TODO ansatz für tabs in awesome wm formulieren
*** TODO google awesome wm borders
*** TODO testen was genau shifty macht, und das gegebenenfalls einrichten
*** TODO übersicht zu den spaltenbefehlen anfertigen
*** TODO übersicht zum Code und dessen config möglichkeiten anfertigen
*** TODO nochmal die awesomewm konfiguration für tab's raussuchen und versuchen einen Plan zu entwickeln, um dieses sicher zu implementieren
** DONE eshell							    :PROJECT:
   - State "DONE"       from "TODO"       [2013-01-23 Mi 12:41]
*** DONE Autocompletion Eshell googlen Ziel: Möglichkeit umzuschalten. Vielleicht andere Shortcuts?
*** DONE Autocompletion eshell fixen im moment wird bei tab direkt eingesetzt und es lässt sich nicht weiter schalten
*** DONE mehrere eshell's, und diese sollten auch von überall aus in einem separaten Frame geöffnet werden können
    - State "DONE"       from "NEXT"       [2013-01-23 Mi 12:41]
*** TODO google Symlink / alias eshell
      
* copy and paste
(yank in emacs = paste)

- C-v in pentadactyl

- "+ vorgeschaltet, präzisiert das clipboard (register)
- y => kopiert in kill ring
- p => pastet aus kill ring
- "a y / p => kopiert/pasted in/aus register a
- M-v paste aus Clipboard durch emacs
- C-@ setzt mark (ab da wird markiert)
- C-Shift-v paste im Terminal
- "+ ;y kopiert Link in pentadactyl
- C-einfügen kopieren durch Emacs
* linux allgemein
 + aumix oder alsamixer für soundsteuerung
 + alternativ einfach sound bei kupfer
 + evince ist der pdf viewer
 + xrandr:  $ xrandr --output VGA --mode 1280x1024 --right-of LVDS
 + convert pic123.png -resize 10% res_pic.png  :: resizing
 + standby :: sudo /etc/acpi/sleep.sh
 + standby_alternativ :: sudo pm-hibernate / powersave / suspend ...
 + script von überall asuführbar machen :: sh entfernen, bang(#/bin/bash) anfügen, und in /usr/bin verschieben
** wlan
wicd-ncurses um netzwerk zu konfigurieren
** standby
sudo chmod u+s /usr/sbin/pm-suspend
sudo visudo
   und da:
florian ALL = NOPASSWD: /usr/sbin/pm-hibernate
florian ALL = NOPASSWD: /usr/sbin/pm-suspend

immernoch sudo eingeben, aber kein passwort mehr
pm-suspend kann dann einfach in synapse eingegeben werden
** mounten
- sudo modprobe usb-storage 
  dann werden die festplatten erkannt
- /etc/modules
den Rest mit pysdm
** Standardprogramme
 + Standardprogramme: ~/.locale/share/applications/mimeapps.list
 application/pdf=zathura.desktop
** funktionierende Soundeinstellung:
- als root starten
- Sound:
  - Output
    - Built In Analog Stereo
    - Connector: Headphones
  - Input
    - Connector: Front Microphone
    - Built-an Audio Analog Stereo
  - Hardware
    - Built-in Audio
      - Profile: Analog Stereo
- Skype:
  - Audiogeräte
    - Mikrofon: HDA ATI SB, ALC887-VD Analog Direct hardware device without any conversions (hw:CARD=SB,DEV=0)
    - Lautsprecher/Klingeln: Default
* synergy
** keyboardlayout
- nacktes setxkbmap beim client hilft
** momentan funktionierendes Setup
 (pfeiltasten machen manchmal trotzdem probleme, der rest funktioniert aber, einschließlich esc)
      nach hinten löschen, aber leider nicht
- alles ordentlich resettet
- auf pc läuft neo mit manueller ladung
- auf laptop eigentlich egal (setxkbmap, aber vorher mit altgr standard resettet)
- mit synergy --help tool geladen, und dort alle fixes installiert
*** entsprechende config
 halfDuplexCapsLock = true
                halfDuplexCapsLock = true
                halfDuplexNumLock = true
                halfDuplexScrollLock = true
                xtestIsXineramaUnaware = true
                switchCorners = none 
                switchCornerSize = 0

** ServerConf
#~/.synergy.conf
section: screens
	florian-ThinkPad-X121e:
	flo_laptop:
end
section: links
	florian-ThinkPad-X121e:
		left = flo_laptop
	flo_laptop:
		right = florian-ThinkPad-X121e
end
section: options
	 keystroke(control+1) = switchInDirection(left)
	 keystroke(control+2) = switchInDirection(right)
end 
** ClientConf
conf wird gar nicht geladen o.O
Aufruf:
synergyc -n flo_laptop 192.168.2.30
** bla
 + Synergy zum Maus/Tasta sharen
   1. auf beiden quicksynergy starten
   2. server ip (ifconfig) bei client eintragen + name
   3. diesen Namen bei server in richtung eintragen und executen
   4. client executen
** Tasten remappen
xvkbd -xsendevent -no-sync -delay 20 -text "-"
xbindkeys --defaults > /home/florian/.xbindkeysrc
xbindkeys-config    <= und da den xvbkd kram einstellen
* Orgmode
** org-protocol
über emacsclient können auch direkt per konsole
solche Aufrufe gemacht werden
[[http://orgmode.org/worg/org-contrib/org-protocol.html][hauptseite]]
*** Browser
javascript:location.href='org-protocol://capture://x/'+
      encodeURIComponent(location.href)+'/'+
      encodeURIComponent(document.title)+'/'+
      encodeURIComponent(window.getSelection())

Sendet diese Daten an Emacs Template, (hier konkret x aber kann 
man auch weglassen)
*** Emacs
vorallem musste erstmal der server gestartet werden

(setq org-capture-templates
      (quote
       (("w"
         "Default template"
         entry
         (file+headline "~/Zettelkasten/zettelkasten.org" "Notes")
         "* %^{Title}\n\n  Source: %u, %c\n\n  %i"
         :empty-lines 1)
        ;; ... more templates here ...
        )))

- Ersetzt templates durch liste mit diesem Template
- Name Default template mit key w
- Subtree mit manuell eingegebenen Titel, unter Überpunkt
  Notes mit aktuellem Datum und dem Titel der source
- überall ne leere zeile dazwischen
** inline bilder
*** link_linie entfernen
(set-face-underline-p 'org-link niPl)
mit org-display... gibts keine
Linien, und es reagiert sofort
*** bilder anzeigen
iimage-mode / iimage-recenter
[ [file:datei123.png] ]

alternativ:
org-display-inline-images
<= zeigt direkt keine linie
** Folding unterdrücken
- für freie Zeilen oben Punkt zusammenfolden, beim nächsten Punkt
an den Anfang und Enter (einrücken schadet auch nicht
- ansonsten # + BEGIN : irgendwas     # + END:
- oder # + BEGIN_ irgendwas und # + END_ irgendwas
- mann kann auch feste drawer am anfang definieren und benutzen
- bei listen, also verwendung von + und - wird
  nach der Einrückung gefoldet
** Regionen/Enviroments
= org-special
- tangling wert ungleich yes und no wird als Dateiname interpretiert
- mit org-babel-tangle werden dann die Dateien erstellt
*** Syntax
#+BEGIN_X
#+END_X

#+BEGIN_LaTeX
\documentclass ...
#+END_LaTeX
*** Allgemeines
- wird auf jeden Fall anders formatiert(alles grau)
- durch Variable org-src-fontify-natively wird auch
  im Org-Fenster das richtige Syntaxhighlighting 
  im Codeblock benutzt
- C-c ' :: öffnet den Inhalt der Region tempoär in nativem Buffer. Dieser
	   muss mit der selben Tastenkombination beendet werden
*** Beispiel Syntax mit möglichem Tangling

#+BEGIN_SRC latex :tangling st-temp.tex
  \documentclass[11pt]{amsart}
  
  \begin{document}
  $\frac{A+B}{C+D} = X*Y = \binom{123}{456}$
  \end{document}
#+END_SRC

*** streaming
- leider noch keine Möglichkeit gefunden das ganze mit externen Dateien zu verknüpfen,
was ist mit Annotationen?
- das würde normalerweise auch erst beim exportieren gemacht werden (Stichwort: tangling)
- für Code Tangling bieten sich dann die 

** Capturing
Man setzt irgendeine Datei als default note file und 
da wird dann immer reinkopiert
(setq org-default-notes-file (concat org-directory "/notes.org"))

Die Funktion org-cature wird dann mit einer Taste verbunden
(define-key global-map "\C-cc" 'org-capture)
Es wird dann jedes mal ein Tempoärer Buffer geöffnet und angezeigt, 
in welchem man ein Template auswählen kann, welches dann dieses Fenster
schonmal vorbefüllt. Da kann dann z.B. automatisch der zuletzt gestörete 
Link oder der Zwischenspeicher oder eine Link zum aktuellen Punkt landen

Unterschieden wird dann noch in Finish, also fertig kopieren und 
Refiling, wobei die Daten an einen anderen header geschickt werden
** Templates
Templates sind im Grund nur etwas Text der Standardmäßig reingespastet wird,
wobei sie aber auch ein paar gegebene Parameter verwenden können.
*** capture-template hinzufügen
Zeug wird unter Heading "Tasks in gtd.org eingefügt
     (setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
             "* TODO %?\n  %i\n  %a")
        ("j" "Journal" entry (file+datetree "~/org/journal.org")
             "* %?\nEntered on %U\n  %i\n  %a")))
Aufbau: Key;Beschreibung; typ: entry=node..., item, checkitem, plain,...;
target: file+regexp/file+id usw, file+datetree für currentdate und noch mehr;
template: text; properties: clockingkram, appenden, unnarrow(nicht hinspringen...)
*** nutzbare parameter
http://orgmode.org/manual/Template-expansion.html#Template-expansion

** refiling
- Das capture oder node wird an anderen header angehangen
(standardmäßig wird nur die oberste ebene benutzt
** Export
*** Export subtree
1. auf subtree gehen
2. org-export
3. 1 um auf subtree export umzuschalten
4. konkreten export aussuchen
* Vim
** Search/Replace                                                :shortcuts
	    =Änderungen werden komplett live gepreviewed=
	    :bereichs/foo/bar/g  oder gc
	    als Bereich kann man z.B. mit a',b' marker angeben
	    Ferner sind auch . für die akt Zeile oder konkrete
	    Zeilennummern möglich, geht aber auch +2 = relativ zu cur-pos
	    oder anders:
	    :g/^test/s/foo/bar/g  nur zeilen die mit test anfangen
	    im grunde gibt man start,end an.

	    \( \) macht aus nem Bereich ne Backreferenz
	    \1 matched die nummeriert, & matched das ganze Teil
	    
	    '< , '> selection anfang / ende
	    $ Dateieende
	    . aktuelle zeile
	    /test/ zeile mit nächstem vorkommen von test
	    ?test? zeile mit vorherigem vorkommen von test
** Mehrfachmanipulation
v -> visual, V -> visual zeile, ctrl v -> block
dann mit i,a,I,A usw. editieren (nach enter bei allen zeilen)
** kleinkram
s(jetzt k) löscht geht aber direkt auf insert
:w !sudo tee > /dev/null %  wenn die Berechtigung bei Vim fehtl
    alternativen: :%!sudo tee %
sudo chmod -v -R ouag+rw *     alles per chmod freigeben

** Vervollständigung
   - Ctrl+n für dynamische 
     Vervollständigung / Ctrl+p für letzte Vervollständigung (sucht
     im Text auch in genau diesen Richtungen !! )
   - Ctrl+x Ctrl+n und Ctrl+x Ctrl+p um ganze 
     Zeile so zu vervollständigen
* Emacs  
** shortcuts-emacs 						  :shortcuts:
    sudo chmod -v -R ouagrw . matched auch verstecktes
   - igrep und dann regex um dateien zu (durch-)suchen
   - recentf-open-files ::   zeigt die letzten dateien an
   - deft-new-file ::        erstellt eine kurznotiv die mit deft
     zusammengefasst werden können
   - C-x C-e :: führt aktuelle lisp zeile aus und gibt ergebniss aus
   - M-esc : :: eval-expr
   - C-x b  ::  buffer wechseln
   - winner-undo :: Layout wiederherstellen (tempoärer speicher)
   - repeat :: .
   - vergrößern/verkleinern :: C-x } /
   - finde Buffer :: C-x 4 C-o
   - InsertPoint :: Ctrl + w (mehrfach für größere Fläche

   - save-current-configuration :: C-ä w
   - resume :: C-ä c
	       
   - show shortcuts :: C-ä 
** zusätzliche Tastenbelegungen
- Belegung von C-x auf cx usw: 
   (define-key evil-normal-state-map "c" nil)
   (define-key evil-motion-state-map "cu" 'universal-argument)
   (define-key key-translation-map (kbd "ch") (kbd "C-h"))
   (define-key key-translation-map (kbd "cx") (kbd "C-x"))
- Belegung von Keychords:
  schnell oder gleichzeitig hintereinander gedrückt
  auch in kombi mit C-x auf cx möglich: xx = C-x
- die F Tasten und verstärkte Nutzung motion mode
** Hilfefunktionen
-    M-x apropos :: findet alles was irgendwie mit dem Ausdruck danach zu tun hat
-    F1 / M-x Helper-... :: findet Keybinds <=> Funktion usw
-    apropos-documentation :: durchsucht alles nach einem String
     
** Funktionsnamen abkürzen
(defalias 'langer_name 'abkuerzung)
** Tmp Keymaps
    blablabla
    testtest
    testetst

    einfach zeile yanken, eval-expr.. und paste mit ctrl-y
    oder auf zeile und C-x C-e, oder markieren und eval-region
      (global-set-key (kbd "C-ß") 'clipboard-yank) *nichtmehr notwendig*
      (global-set-key (kbd "C-c f") 'evil-emacs-state)
      (global-set-key (kbd "C-c q") 'evil-force-normal-state)
      (define-key evil-normal-state-map (kbd "C-c f") 'evil-emacs-state)
      (define-key evil-normal-state-map (kbd "C-c q") 'evil-force-normal-state)
      (global-set-key (kbd "C-u") 'evil-scroll-up)
      (define-key evil-normal-state-map (kbd "C-u") 'evil-scroll-up)
      (global-set-key (kbd "M-k") 'evil-window-prev)
      (define-key evil-normal-state-map (kbd "M-k") 'evil-window-prev)
      (global-set-key (kbd "C-c b") 'view-buffer-other-window)
      (global-set-key (kbd "C-ü") (lookup-key global-map (kbd "C-x")))

      (global-unset-key (kbd "C-d"))
      (local-unset-key (kbd "C-d"))
      (global-unset-key "\C-d")
      (local-unset-key "\C-d")

      (global-set-key (kbd "C-d") 'evil-scroll-down)
      (define-key evil-normal-state-map (kbd "C-d") 'evil-scroll-down)
      (define-key evil-motion-state-map (kbd "C-d") 'evil-scroll-down)
      (local-set-key (kbd "C-d") 'evil-scroll-down)
       (define-key evil-normal-state-map "\C-d" 'evil-scroll-down)
      (define-key evil-motion-state-map "\C-d" 'evil-scroll-down)
      (local-set-key "\C-d" 'evil-scroll-down)

      (define-key global-map "\C-d" 'evil-scroll-down)

      (define-key local-map "\C-d" 'evil-scroll-down)

; freie Präfixe sind C-ü , C-ö , C-ä



      [[file:~/.emacs::(global-set-key%20(kbd%20"C-c%20b")%20'][.emacs]]

** helm :shortcuts:
[Space] scrollt in Hilfstext
M-a markiert alle Einträge !!!

** Zeilenumbruch
   + linewrapping = darstellungsumbruch
   + truncating = nicht umbrechen
     => toggle-truncate-lines
   + columnfilling => zeilenumbruch im Buffer
     => auto-fill-mode bricht automatisch um
     => set-fill-column setzt die max. Zeichenanzahl
** FTP
1. mit Befehl ftp, ftp programm aufrufen
2. da dann adresse für server eingeben (www.howtoflo.de z.b.)
3. dann benutzernamen eingeben (web95) z.B.
4. dann Passwort eingeben

+ mit ls und cd bewegen
+ mit rename umbenennen
+ mit put lokale/adresse remote/adresse Dateien hochladen
  für zielpfad reicht auch einfach der zieldateiname, so dass
  der aktuelle Ordner benutzt wird
+ mit get? entsprechend runterladen
** GNUS
Adresse => 212.82.96.94
*** weiterleitung für mehrere Accounts auf dem selben server
nslookup imap.mail.yahoo.com    zum schluss kommen die interessanten ip's
echo "12.34.56.78 neue.mail.domain" >> /etc/hosts
*** konfiguration
;; GMANE is about the only free news server I've seen.
;; I set it to my primary server so I can read a few Free software mailing lists.
(setq gnus-select-method
     '(nntp "news.gmane.org"))
;; Mostly, though, I just want to read my mail.
;; This setup uses a standard SSL-based connection to read the mail for the accounts I have through
;; UC Berkeley:
(setq gnus-secondary-select-methods
      '((nnimap "floppycode" ; primary email
		(nnimap-address "imap.mail.yahoo1.com")
		(nnimap-server-port 993)
		(nnimap-authinfo-file "/home/florian/.authinfo")
		(nnimap-stream ssl))
	(nnimap "lerch.florian" ; secondary account
		(nnimap-address "imap.mail.yahoo2.com")
		(nnimap-server-port 993)
		(nnimap-authinfo-file "/home/florian/.authinfo")
		(nnimap-stream ssl))
		))



(setq gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")

(setq user-mail-address "floppycode@yahoo.de")
(setq user-full-name "Florian Lerch")

;(setq mail-sources '((nnimap :server "imap.mail.yahoo.com"
;                          :user "floppycode@yahoo.de"
;                          :password "")
;		     (nnimap :server "imap.mail.yahoo.com"
;			  :user "lerch.florian@yahoo.de"
;			  :password "")))


(setq send-mail-function 'smtpmail-send-it)
(setq message-send-mail-function 'smtpmail-send-it)
(setq smtpmail-default-smtp-server "smtp.mail.yahoo.com")

(setq smtpmail-auth-credentials '(("smtp.mail.yahoo.com" "465" "floppycode@yahoo.de" "3ihgvks14")))
(setq smtpmail-starttls-credentials '(("smtp.mail.yahoo.com" "465" nil nil)))
*** .authinfo
machine imap.mail.yahoo1.com login floppycode@yahoo.de password secret port 993
machine imap.mail.yahoo2.com login lerch.florian@yahoo.de password secret port 993
* install/make kram
1. ./configure
2. make
3. sudo make install
* Firefox
** pentadactyl plugins
*** installieren
js Datei in ~/.pentadactyl/plugins/ kopieren
*** Grundstruktur
eigentlich nichts festes, geht direkt mit js code los
*** Kommando hinzufügen
group.commands.add(['command_name'], "Beschreibung",
 function(args){
  var = bla;
  mache_irgendwas;}
);
*** Hintmode hinzufügen
hints.addMode('K', "descr", function(elem) {
	     var url = elem.getAttribute("href");});
*** nutzpare Parameter
var url = buffer.url;
var en_url = encodedURIComponent(buffer.url);
var title = buffer.title;
*** Aufruf Org Protocol(Capturing)
capture_template mit kürzel w:
#+Begin: Javas Code
location.href='org-protocol://capture://w/'+
  encodeURIComponent(location.href)+'/'+
  encodeURIComponent(document.title)+'/'+
  encodeURIComponent(buffer.win.getSelection())
#+END:
passendes Capture-Template: (titel muss noch manuel eingegeben werden)
#+BEGIN: CaptureTemplate
(setq org-capture-templates
      (quote
       (("w"
         "Default template"
         entry
         (file+headline "~/org/capture.org" "Notes")
         "* %^{Title}\n\n  Source: %u, %c\n\n  %i"
         :empty-lines 1)
        ;; ... more templates here ...
        )))
#+END:
passendes Capture-Template: (titel muss nichtmehr eingegeben werden und
es wird auch sonst nichts vom capture menü angezeigt
#+BEGIN: CaptureTemplate2
(setq org-capture-templates
      (quote
       (("w"
         "Default template"
         entry
         (file+headline "~/org/capture.org" "Notes")
         "* Testtitle\n\n  Source: %u, %c\n\n  %i"
         :empty-lines 1 :immediate-finish :unnarrowed :kill-buffer)
        ;; ... more templates here ...
        )))
#+END:

+ Paremeter werden getrennt mit / und encdode...
+ zuerst link , dann titel, dann content 
+ %c setzt link mit passendem Titel ein
+ %i setzt das capturing ein
+ %u setzt das aktuelle datum oredntlich formatiert ein
+ die 3 übertragenen Daten sind auch abrufbar mit:
  + %:link        => der link
  + %:description => der Titel
  + %:initial     => der content
+ template wird mit "x" gewählt
 

** pentadactyl einrichten
- :map d V   <= damit der nicht mit d seite löscht
- :set hintkeys=uiaenrdxvlchgqüöäpb,.j
- :mkpentadactylrc
** Standardsuche
about:config und da nach keyword.URL suchen und
https://www.google.com/search?hl=en&q=  einsetzen

** Extensions
+ Bugmenot
  viel zu viel gesperrt und son Scheiß. Für die Fälle wo's sich trotzdem
  lohnt, reicht auch die Website
+ CoolPreviews
  meine fresse ist das eine langsame Reaktion gewesen
  die Suchen funktioniert irgendwie nicht, und auch sonst ist
  die Reaktionszeit für normale links extrem langsam, das Interface
  selbst ruckelt auch pervers
  andererseits kann das von Zeit zu Zeit sicherlich auch Tabs einsparen
  auch wenn kurz öffnen und zurückgehen vermutlich schneller wäre
  die stacking funktion ist auch irgendwie scheiße weil langsam und unübersichtlich
  könnte aber fürs nächste vielleicht zu mehr ordnung motivieren
+ DeeperWeb
  also dezent würd ich die sidebar nicht grade nennen, stopft das halbe fenster zu
  der Wert der angezegiten Tags ist 'begrenzt'
  teilweise sind aber interessante Suchansätze implementiert, deren Umsetzung ist zwar
  Scheiße, aber auf Basis dessen lässt sich sicherlich noch besseres finden
+ DownloadHelper
  integriert sich ganz gut und enthält einen converter, nichts auszusetzen
+ Element Hiding Helper Adblock Plus
  funktioniert ziemlich gut -> seiten lassen sich schnell extrem vereinfachen
  -> leider kein redo oder preview?
+ Fasterfox
  konnte bisher keinen Echten leistungsanstieg feststellen
+ fastestfox
  verschiedene "downthemall-artige" Funktionen
  diese kleinen buttons beim link sind eigentlich nur nervig und schwul
  aber die kleine wikipedia preview für markiertes könnte praktisch werden
  automatisches laden der nächsten seite führt öfters mal zu problemen
  Geht mir jetzt schon auf die nerven
+ Instaright!
  wieder so behindert fokussiert auf die eigene Seite
  sehr ruckelige Angelegenheit und bescheuerte Notifications
  behindertes Scheißteil -> weg
+ Multirow Bookmarks
  haben jetzt auch auf ein neues Plugin mit plus am Ende umgestellt >.>
  ficken sie sich
+ Pocket
  bietet die möglichkeit halbwegs effizient die links zu sammeln und synchronisiert
  die dann mit deren Server
  paar shortcuts gibts auch, aber die reichen noch nicht wirklich
+ Read Later Fast
  zwar immernoch scheiße weil immer auf extra Seite, aber bis auf weiteres muss das
  reichen, irgendwie auch etwas verbuggt
  Korrigiere: funktioniert nicht
+ SearchMenu
  klein, schmal und unauffällig, erfüllt seinen Zweck
+ Tile Tabs
  normale Tabs Funktionieren nicht so ohne weiteres,
  => läuft über separates Menü(scheint umschaltbar zu sein)
  ist trotzdem scheiße
+ Vimperator
  im Prinzip schon ziemlich geil, flexibel und bietet viele Möglichkeiten
  im Moment sieht das Design markierter links aber noch echt kacke aus
  und er krallt sich andauernd irgendwelche Tastendrücke und macht
  scheiße damit
  speichert auch die Einstellungen irgendwie nicht
** org-protocol
*** emacs.d
(server-start)
(require 'org-protocol)
*** browser
in ~/.local/share/applications
org-protocol.desktop erstellen mit

  [Desktop Entry]
  Name=org-protocol
  Exec=emacsclient %u
  Type=Application
  Terminal=false
  Categories=System;
  MimeType=x-scheme-handler/org-protocol;

und update-desktop-database ~/.local/share/applications/ laufen lassen
in Firefox dann url öffnen und /usr/bin/emacsclient zeigen
** kopieren
/ -> suche, um zur richtigen stelle zu kommen
c -> caret mode;
v -> visual mode;
dann y -> yank

* Shell
- mit history durchnummerierte Befehlshistory
- schleife in bash :: for i in {1..10}; do echo $i;done
- inhalt durchsuchen :: grep --context=10 oder -C 10   (<- großes C)
- replace :: sed -i 's/old-word/new-word/g' *.txt
- rename :: rename 's/\.bak$//' *.bak
- ausgabe :: cat
- argumente :: !$ (last) !n:1 (arg1 von cmd n)
- befehle :: !! (last) !n (nr) !ls (last ls) ^ust^usr (last mit 1 replace)
- dir :: cd - (last dir) pushd / (cd mit stack) popd (zurück stack)
- ausschnitt :: head -n 2(bis 2) tail -n 2(ab) head -n -2(bis letzte 2)
- einsetzen :: sed -i~ '1 i anfang' Server.java (setzt in zeile 1 ein, ~ = Backup)
- entfernen :: sed -i '1 d' Server.java (löscht Zeile 1)
- variablen/zwischenspeicher :: set varname = blakramzeug
* yas
** neu erstellen
Ctrl-ä n  -> neu
Ctrl-ä t  -> load buffer
-> fertig
der key wird dabei expanded
** Beispiel Snippet
# -*- mode: snippet -*-
# name: leftrightarrow
# key: Lra
# --
\Leftrightarrow
** Input
${1} für Eingaben, ${1:bla} oder sows für Vorschläge
dann Lra in Latex eingeben und tab -> ersetzung
Bei kopien wird dann bloß noch $1 geschrieben
(muss auch!! Die klammern sind nichtmehr erlaubt)
Für mehrere Auswhal möglichkeiten:
<div align="${2:$$(yas/choose-value '("right" "center" "left"))}">
* git
   *HEAD -> Branch -> Commit*
** Keywords
(teilweise direkt mit git <keyword> als befehl)
- ref :: reference, verknüpfung, konkret id oder so
- repository :: Container mit Daten / Veränderungen und allemm
- commit object :: dateien, die den aktuellen stand zu zeitpunkt
		   repräsentieren (hat auch n namen und so)
		   oft auch nur veränderungen und link zu parent
- head :: ref auf commit objekt, im grunde nur id/name (= sha1)
	  HEAD ist der akt. aktive vom akt. Repo
- branch :: unterschiedliche ableitungen eines repositories, für gewöhnlich
    also daher durch head repräsentiert (entspricht besonderem commit, häufig tempoär)
- merge :: (synt.: git merge [head]) pflegt das commit objekt von head
	   in das aktuelle repository ein
	   -> sucht gemeinsamen vorfahren, von akt. commit und neuem
	   -> wenn alles glatt geht einfach überschreiben, sonst manuelle entscheidungen
	    bzw. entsprechende Marker um User zu warnen
	   -> Konflikt, beide Mergehistorien haben zu gleichem Zeitpunkt widersprüchliche
	    Änderungen
	   sonst Fast Forward, jeweils immer nur eine Veränderung( geht automatisch)
- checkout :: HEAD auf commit lenken, und dann die lokalen Daten überschreiben;
	     konzentriert sich dabei auf staged files und so
- diff :: unterschied zwischen 2 commits (also heads übergeben)
- log :: commit zur tempoärem Vorgänger
- remote :: repository das nicht lokal ist
	    remote repository bekommt rem rep ref (standard origin) als identifikation
	    remote heads, verlinken die heads(-> commits) in rem rep
	    (syn.: origin/[head-name]
- track :: lokaler branch repräsentiert intern remote branch (tracked diesen also, ist ref)
	   alle notwendigen Daten liegen lokal abgespeichert
- fetch :: neue commits aus getracktem branch werden in trackendem branch gesichert
	   nur remoteheads verändern sich
- master :: lokaler hauptbranch (standardmäßig), kann auch selbst tracken
- pull :: passt die heads dem fetch an (wenn tracking eingerichtet, erfolgt erkennug
	  des remote repositories und vorhergehender fetch automatisch
	  übernimmt dabei also vorrangig allos von eimen (meist remote) Rep
- push :: fügt remote repository die commits hinzu und der lokale headlink wird zu der
	  passenden Modifikation weitergeleitet
	  remote head reference usw. werden in lokalme branch auch angepasst
	  ! rem head muss zu vorgängen von akt. rem rep zeigen und dort einsetzen!
	  -> fast forward merge wird forciert
- index :: sammlung der dateien, die zum repository committed werden sollen
	   bilden die Grundlage um commit objekte zu bilden
- commit :: bilden und hinzufügen von commit objekten zu repository
- working directory :: der ordner in dem die daten liegen, die man selber wirklich bearbeitet
- stash :: container für nicht committete Modifikation, um mit akt. rep zu mergen
- status :: zeigt differenzen: working-directory <-> index <-> aktuellster commit
	    => wd enthält alle dateien, index nur 'tracked' dateien, und akt. commit die 'staged',
	    die nach bisherigem Stand auf jeden fall reinkommen.
- staged :: fürs nächste commit vermerkt
- reset :: setzt den HEAD 'link' zurück, (zu spezifischem Stand),
- mv|rm|ect :: können dies jeweils in workdir aber auch pushbaren commits machen
	       und den Rest auch gleich anpassen
** dateien aus dem kreislauf ziehen (aber erhalten)
1. in underordner und .git/info/exclude jeweils ausnahme hinzufügen
2. git update-index --asume-unchanged <filepath>    ab -- vlt optional
3. git rm --cached filepath
4. git update-index --asume-unchanged <filepath>    keine ahnung ob nochmal

5. git commit -m "bla"
6. git push
** dateien hinzufügen/updaten
ob eine Datei  ganz neu ist, oder sich nur verändert hat, macht erstmal
   keinen Unterschied. Mit git add werden Dateien hinzugefügt.

** spontan konkretes committen
    git add --patch     lässt dann wählen was gemacht wird
** lokalen datenbestand updaten
git pull

git checkout
git
** config
remotebranch mit namen origin ist default für push/pull
=> ist in .git/config
die exclude ignorelist kann direkt dateinamen aus 
dem wurzelverzeichnis entgegennehmen
git config --global credential.helper cache
git config --global credential.helper 'cache --timeout=50000' <= cached login
** praktische befehle
git add . addet alles außerhalb der ignorelist (vorher git status ...)
git mergetool  um den kram zu mergen
** mit gui
gitk => git-gui öffnen => neu laden
=> alles bereitstellen => nein => eintragen => versenden
** Ganz neues Projekt
1. Mit git initialize oder so, erstmal lokal rep erstellen
2. Online irgendwo was erstellen
3. git remote add name pfad
4. git update name
5. git commit -m "bla"
6. git fetch name
7. nochmal add und commit
8. git pull name -t master
9. git commit -m "bla"
10. git push name
11. config mit default remotes updaten:
    [branch "master"]
    remote = origin
    merge = refs/heads/master
** neue basis pushen (überschreiben)
git push remote_name --force
** neues system mit online repo verbinden
git init     für neues lokales rep
git add      mit allem was man dabei haben möchte, ggbflls. vorher gitignore
git remote add rem_name online_path -t master
(git push rem_name --force) falls repository neu bespielt werden soll
** Fehler beheben
- mit git log die einzelnen commits inkl nummer anzeigen
- mit git show nr:pfad z.B. 1234:.emacs.d/test.txt dokumente etc anzeigen

** allgemeiner Synchronisationsworkflow
+ C-ö m s  für Status (und speichern)
+ jeweils i oder s zum anpassen
+ c  "bla" C-c C-c
+ C-ö m l
   + C-ö m s  wieder stagen
   + c C-c C-c
+ C-ö m h

und beim nächsten Rechner dann das gleiche
* eshell
- cd = für stack, cd -nr  um aus stack aufzurufen
- & ganz ans Ende (hinter paramater usw.) um
  Prozess abzuspalten
  - wahlweise noch mit nohup davor
  um output abzuleiten
  for i in 1 2 3 4 5 6 { rm bla$i.jpg }
  for i in (number-sequence 1 6) {rm bla$i.jpg }
* zipper
- tar.gz :: tar xvfz filepath
- zip :: unzip filepath
* Latex
- latex selbst konvertiert zu dvi
- programme wie dvipng machen daraus bild
- documentclass[11pt]{standalone} erstellt
  eine Seite mit minimaler größe (für formelextraktion)
- iimage-mode <- zeichnet einfache links zu bildern
  iimage-recenter läd die bilder dann nach
** beispiel für nutzung von latex_headern in babel
 #+LATEX_CLASS: article
 #+LaTeX_HEADER: \usepackage{minted}
 #+LaTeX_HEADER: \usemintedstyle{emacs}
 #+LaTeX_HEADER: \newminted{common-lisp}{fontsize=\footnotesize}

 #+name: setup-minted
 #+begin_src emacs-lisp :exports both :results silent
     (setq org-export-latex-listings 'minted)
     (setq org-export-latex-custom-lang-environments
           '(
            (emacs-lisp "common-
** beispiel latex mit result block
#+begin_example
#+name: tabularx-export
#+begin_src latex :exports results :results latex :noweb yes
  \begin{table}[htb!]
  \centering
  \footnotesize
  \caption{A table to test booktabs}
  \label{tab:test-table}
  <<booktabs(table=test-table,align="lrX",env="tabularx",width="\\textwidth")>>  
  \end{table}
 #+end_src
#+end_example
When you export the file to LaTeX, this code block is expanded in a #+results: block and wrapped in #+BEGIN_LaTeX … #+END_LaTeX. If the table has column heads, then the rule beneath them should be finer than the rules at the top and bottom of the table.
** arrays
$\begin{array}{ccc}
q_0 & q_1 & q_2 \\
q_0 & q_1 & q_2 \\
q_0 & q_1 & q_2 \\
$\end{array}
** beispiel image link
[ [ file:~/test1.png ] ] 
; das file: am anfang ist wichtig!
** minimales latex Skript
\documentclass[11pt]{standalone}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}

\begin{document}
$\frac{A}{B} = c$

\end{document}
 
** preview im org mode
zeichen hinter $ muss frei sein
alternativ: \( und \) für kleine schrift oder
\[ \] oder $$ $$ für größere Schrift
* Windowmanager

   :PROPERTIES:
   :ID:       0001
   :END:
** *Kriterien*
  - hohe Geschwindigkeit und Ressourcensparend

  - sollte die Standardlayouts schnell aufbauen können
  - intuitives Verändern der Layouts per Tastatur (größe und pos der Felder)
  - zuordnen mehrerer Workspaces bzw. Tags / Gruppen
  - einfache Konfiguration, am besten Live/über GUI oder tool
  - aktive Entwicklung
  - vorhandensein und kompatibilität zu wichtigen widgets
  - Maus ist immernoch -möglich-
  - schnelles setzen des Fokus auf konkretes Fenster möglich
** *Theorie*
DynamicWindowManager :: tiling *und* freies Verteilen
TilingWindowManager :: Fenster liegen nie übereinander
StackWindowManager :: Fenster können übereinander liegen

** Awesome WM
- tagging ganz cool aber auch nicht mehr als mehrfache workspace
  zuordnung
- jede Konfiguration über die Datei, nichts geht einfach über
  Packagemanager
- Widgets machen irgendwie Probleme und Design von Fenstern scheiße
- Focus Management noch nicht perfekt, generell mangel an
  Usability Innovation
- zuschalten von Fenstern geht flüssig, schnell und sauber
*** Fenster in bestimmten Tags starten
 -- {{{ Rules
awful.rules.rules = {

    -- All clients will match this rule.
    { rule = { },
      properties = { border_width = beautiful.border_width,
                     border_color = beautiful.border_normal,
                     focus = true,
                     keys = clientkeys,
                     buttons = clientbuttons,
                     size_hints_honor = false} },
    { rule = { class = "MPlayer" },
      properties = { floating = true } },
    { rule = { class = "Chromium" },  properties = {tag = tags[1][1]}},
    { rule = { class = "Luakit" },  properties = {tag = tags[1][1]}},
    { rule = { class = "Geany" },  properties = {tag = tags[1][2]}},
    { rule = { class = "libreoffice-writer" },  properties = {tag = tags[1][2]}},
    { rule = { class = "Terminator" },  properties = {tag = tags[1][3]}},
    { rule = { class = "Vlc" },  properties = {tag = tags[1][4]}},
    { rule = { class = "Desmume" },  properties = {tag = tags[1][4]}},
    { rule = { class = "Easytag" },  properties = {tag = tags[1][4]}},
    { rule = { class = "Galculator" },  properties = {tag = tags[1][4]}},
    { rule = { class = "Gpartedbin" },  properties = {tag = tags[1][5]}},
    { rule = { class = "Gtg" },  properties = {tag = tags[1][5]}},
    { rule = { class = "Pcmanfm" },  properties = {tag = tags[1][5]}},
    { rule = { class = "Transmission" },  properties = {tag = tags[1][5]}},
}
-- }}}
*** shortcuts-awesome wm 					  :shortcuts:
S-n       :: minimieren
S-C-n     :: wiederherstellen
^S-c      :: schließen
S-t       :: oberste Ebene
^S-j / k  :: Fenster verschieben
S- h/l    :: Breite verändern
^S-h/l    :: mehr/weniger Hauptfenster
S-C-h/l  :: mehr/weniger Spalten Slaves
^S 1-9    :: ändere Fenster tags auf 1-9
^S-C 1-9  :: Füge Fenster Tag hinzu

*** mehrere Bildschirme
- mit dem xrandr Befehl aus dem Softwarebreich starten
- mit mod4+o werden die Fenster verschoben
- mit mod4+ctrl wird der fokusmonitor gewechselt
** wmii :kandidat:tested:
- Ressourcensparend
- sehr nah an z.B. DWM aber mit mehr Features etc.
- Features haben auch keine offensichtlichen Makel
- kann in beliebigen Sprachen entwickelt und verändert werden
- es existieren viele Pakte solcher Modifikationen
*** Test
- shell funktioniert auf anhieb
- sondertasten neo nicht im startmenü, was aber ansonsten ganz gut läuft
- scrollbars irgendwie eigenartig
- ruckelige Darstellung
- tagzuweisung klappt ganz gut
- generell, sobald maus benutzt wird wirkt alles verbuggt
- autofokus auch erstmal nicht drin
- design sehr minimalistisch <- hat nen eigenen reiz
- zusammenklappen ist aber ziemlich intelligent:
  ein Fenster kann per Knopfdruck auf die komplette Spalte maximiert
  werden und der rest wird nur am rand eingeblendet
- Shortcuts
  [[/home/florian/Dropbox/Zettelkasten/zettelkasten.org_20121213_230622_11330eFl.png]]
  - mod t = springe zu tag, mit shift auch setzen
(Press "Alt + a" to log out, well select "exit")

- ganz geil ist, das man nicht auf tagnummern achten mussten
  sondern einfach anfängt den namen einzugeben und dann codecompletion
- das Springen zwischen Master und dem Rest ist wirklich gut umgesetzt
  (einfach durch sprung nach links/rechts usw)
- zB der DocumentViewer läuft ganz gut und kupfer geht auch
- emacs verhält sich auch nicht auffällig
- tagnummer mappt nicht auf unterschiedliche Namen? oO
- die Balken die noch da sind, sind aber eigentlich auch nur störend
** Qtile :kandidat:tested:
- basiert auf python
- noch recht schnell und klein, leicht modifizierbar
- hat auch ne nett gemachte Projektseite usw.

*** Test
- design im Kern sehr schick und sehr spartanisch
- modifizierung über python scheint auch gut möglich zu sein
- das standardmäßig vorgegebene beispiel ist aber schrott
** Xmonad :kandidat:tested:
popluär, flexibel und frei, auf jeden fall
ein kandidat
http://xmonad.org/tour.html
*** Test
- Termninal läuft
- Fensterbalken und son Kram existieren nichtmal
- schafft es aber offensichtlich nichtmal, die windowstaste als mod zu benutzen
- kupfer funktioniert
- die layouts entsprechen erstmal nur den elementarsten basics
- dank dmenu die selbe menüleiste wie bei wmii aber nicht dauernd eingeblendet und neo
  läuft ordentlich
- sehr minimalistisch aber irgendwie schon schick
- alles weitere müsste nachgerüstet werden, aber in diesem Fall
  wäre xmonad sicherlich ein gutes fundament
- plugins laufen über haskell
** herbstluft :kandidat:
- "nachfolger" von Musca
- scheint alles wichtige drin zu haben
- das reicht fürn test

- so auf anhieb geht gar nichts und besonders
viel scheint das internet auch nicht dazu zu haben
- generell noch relativ neu (kaum ein jahr alt)
<.< immernoch nichts geschafft
- wird erstmal auf später verschoben

http://wiki.ubuntuusers.de/herbstluftwm

** wmfs :kandidat:
- scheint alles zu bieten

** i3wm :kandidat:tested:
- hardcore simpler einstieg ABER wlan wird direkt angezeigt
- battery widget auch da, funktioniert aber nicht
- bäh, kupfer bekommt diesen schwuler rahmen aufgezwungen
- erstmal abgestürzt
- steuerung ist aber nicht ungeil (mit simulierten pfeiltasten fenster positionieren
- und die stacks sind drin, die sind schon ziemlich cool
- allzu leicht ist das herstellen eines ganz konkretn aufbaus trotzdem nicht
- stacking ist aber echt geil, und tabbing genauso, sau nützlich
  - leider gibt es jedes mal grelles flimmern beim umschalten
- containern kann man auch irgendwie
- viele wirklich interessante Konzepte umgesetzt, sollte in jeden Fall
  als Referenz für zukünftige Projekte in die Richtung dienen
- viele kleine grafikfehler
- und die tasten werden für shortcuts nach der hardware und nicht neo geladen

** spectrwm :kandidat:tested:
- aktuell und fleißig bearbeitet, alles bestens

- erster blick sehr spartanisch
- fenster sieht am rand etwas kaputt aus
- kupfer funktioniert
- reagiert auch wieder auf alt statt tab
- master kleiner oder größer machen
  ruckelt echt übel
- ansonsten der ganze Standardkram ist sauber umgesetzt
- leider keine echte benennung der layer?
- jedenfalls nichts was es besonders macht
** *----------------------------*
** Fluxbox :rejected:
- bietet zuordnung in tabs an( => Programme die sich auf
  viele Fenster verteilen können zusammengefasst werden)
*** Comment: gleichzeitige Anzeige?
? die Frage ist, ob auch mehrere Tabs gleichzeitigen in einem
Fenster angezeigt werden können, wenns sein muss
+ das selbe Ergebniss lässt sich auch generell mit Tags und workspaces
erreichen

- alle benötigten bars etc. würden sich nachrüsten lassen
- kein tiling -> und tschüss
** UWM :rejected:
- keine Taskleiste usw. => vesucht flexibel produktiv zu bleiben
- dabei allerdings starker fokus auf die Maus
** IceWM :rejected:
- minimalistisch usw. bietet im Endeffekt aber auch nichts wirklich
innovatives oder tolles
** OpenBox :timefiller:
- sehr schnell und beliebt
- kann im Grunde auch nicht mehr
- aber eben wirklich hart ressourcen sparend
- sehr stark und simpel modifizierbar in alle Richtungen
- Tiling nur über über PyTile -> recht Ram aufwendig
** Musca Wm :rejected:timefiller:
- die auswahl der Fenster wirkt sehr spartanisch, mit einfachen
Linien um die Layouts zu bestimmen
- scheinbar auch nicht gerade besonders verbreitet
- die Leute scheinen aber recht begeistert von der Aufteilung
  und der Fenstersteuerung zu sein
*** Readme (sehr groß) mit allen Infos
Musca

- Musca

|@constellation_small.png right@|http://en.wikipedia.org/wiki/Musca| |controls|#controls| : |source|#source| : |author|#author| : |bugs|https://bugs.launchpad.net/musca| : |questions|https://answers.launchpad.net/musca| : |suggestions|https://blueprints.launchpad.net/musca| : |customize|#customize| : |settings|#settings| : |howto|#howto| : |changelog|#changelog| : |mailing list|http://mail.aerosuidae.net/mailman/listinfo/musca_aerosuidae.net| : |launchpad|https://launchpad.net/musca| : |0.9.2|#source|

+A simple |dynamic window manager|http://en.wikipedia.org/wiki/Dynamic_window_manager| for X, with features nicked from |ratpoison|http://www.nongnu.org/ratpoison/| and |dwm|http://www.suckless.org/dwm/|+:

+ Musca operates as a |tiling window manager|http://en.wikipedia.org/wiki/Tiling_window_manager| by default.  It uses `manual tiling`, which means the user determines how the screen is divided into non-overlapping `frames`, with no restrictions on layout.  Application windows always fill their assigned frame, with the exception of transient windows and popup dialog boxes which float above their parent application at the appropriate size.  Once visible, applications do not change frames unless so instructed.

+ Since not all applications suit tiling, a more traditional |stacking window manager|http://en.wikipedia.org/wiki/Stacking_window_manager| mode is also available, allowing windows to float at any screen location and overlap.

+ There are no built in status bars, panels, tabs or window decorations to take up screen real estate.  If the user wants any of these things, there are plenty of external applications available to do the job.  Window decoration is limited to a slender border, which is coloured to indicate keyboard focus.

+ |@musca1_small.png right@|musca1.png| Windows are placed in named `groups` which can be used in a similar fashion to virtual desktops.  Groups can be added and removed on the fly, and each group has its own frame layout.

+ The excellent +dmenu+ utility is used to execute commands and launch applications, and it can also act as a window and group switcher.

+ Windows and frames are navigated and focused on any mouse button click, including rolling the wheel, or alternatively driven entirely by the keyboard.  Simple key combinations exist for window switching, group switching, frame control and screen switching.

+ Frames can be `dedicated` to a single application window, preventing new windows usurping said frame.  One frame per group can also be flagged as a `catch-all` so that all new application windows open there.  The frame border colour changes to reflect these modes.

+ |@musca2_small.png right@|musca2.png| Musca has multi-screen support out of the box, and will automatically create groups for every available screen.

+Thanks to ratpoison and dwm authors+.  Musca's code is actually written from scratch, but a lot of useful stuff was gleaned from reading the source code of those two excellent projects.

+Extra kudos to dwm authors for creating dmenu!+  A true sliced-bread-beating invention.

+But `why` do this when there are 17 million other window managers already swanning about the internet?+  Variety is the spice of life?  Actually, +ratpoison+ is very good and I used it for many years; but, I always wanted it to be just a little bit more friendly to the mouse, and just a little bit more informative about frame focus and layout, and just a little bit less `modal` (I can't think of a better way to say that) everywhere.  Sleek little +dwm+ is also great, and while it does focus-follow-mouse and has nice minimal yet informative frame borders, it can't do manual frame layouts and I couldn't add the feature to it satisfactorily (probably my fault).  Other options like +Ion3+ and +Xmonad+ were also fun, but ultimately had fluff of one sort or another.  So, here is +Musca+: the strange offspring of ratpoison and dwm, and very likely only suited to my preferences ;-)  Oh well.

+Why is it named after a star constellation?+  Firstly, so it didn't have "+wm+" in the name.  Secondly, why not?

-- |Controls\controls|

All Musca key bindings start with a modifier key ("M" below), which is bound to +Mod4+ by default.  Mod4 is usually +Super_L+ or the left hand "Windows" key.  This is most convenient as it leaves Ctrl/Alt free for application use.

See |howto|#howto_mod_key| for troubleshooting or changing the Modifier key.

--- Frame Control

Key bindings:

:table bindings
Keys	Action
M+h	split frame in half horizontally to form two frames.
M+v	split frame in half vertically to form two frames.
M+r	remove the current frame and resize others to fill the gap.
M+o	remove all other frames except the current one, resizing it to full screen.
M+u	revert the last frame layout change.
M+d	(toggle) dedicate the current frame to the current app.
M+a	(toggle) set the current frame as a `catch-all`, where all new windows will open.
M+Left	change focus to the frame on the left.
M+Right	change focus to the frame on the right.
M+Up	change focus to the frame above.
M+Down	change focus to the frame below.
M+Ctrl+Left and M+Ctrl+Right	resize current frame horizontally.
M+Ctrl+Up and M+Ctrl+Down	resize current frame vertically.

Musca commands:

:table commands
Command	Action
hsplit <relative\|pixel>	split frame horizontally.
vsplit <relative\|pixel>	split frame vertically.
width <relative\|pixel>	resize frame horizontally.
height <relative\|pixel>	resize frame vertically.
remove	remove the current frame and resize others to fill the gap.
only	remove all other frames except the current one, resizing it to full screen.
dedicate <on\|off>	(toggle) dedicate the current frame to the current app.
catchall <on\|off>	(toggle) set the current frame as a `catch-all`, where all new windows will open.
focus <left\|right\|up\|down> or lfocus rfocus ufocus dfocus	change focus to a frame in the specified direction.
undo	revert the last frame layout change.
resize <left\|right\|up\|down>	resize the current frame in the specified direction.

Relative values can be specified as a percentage or a fraction:

 hsplit 2/3
 hsplit 33%

+hsplit+ and +vsplit+ adjust frame size relative to `itself`.

+width+ and +height+ adjust frame size relative to the `screen size`, less any group padding.

--- |Window Control\controls_window|

Key bindings:

:table bindings
Keys	Action
M+t	launch a terminal.
M+x	launch an app via dmenu.
M+w	switch windows in the current frame, via dmenu.
M+k	politely close the window in the current frame via a close event.  Press again to forcibly kill it.
M+c	cycle a hidden window into the current frame.

Windows automatically receive the keyboard input when they are visible in a focussed frame.

Musca commands:

:table commands
Command	Action
swap <left\|right\|up\|down> or lswap rswap uswap dswap	swap current window with the contents of the frame to the left, right, up and down respectively.
move <name>	move the current window to the group called `name`.
kill	politely close the window in the current frame via a close event.  Press again to forcibly kill it.
cycle	cycle a hidden window into the current frame.
raise <number\|title>	raise and focus a window in the current group by number (order opened) or title.
manage <on\|off> <name>	(toggle) set whether the window class called `name` is managed or ignored.

--- Group Control

Key bindings:

:table bindings
Keys	Action
M+g	switch groups via dmenu.
M+PageUp	switch to the previous group.  (PageUp == X11 Prior)
M+PageDn	switch to the next group.  (PageDn == X11 Next)
M+s	(toggle) switch the current group between `tiling` and `stacking` window modes.

Musca commands:

:table commands
Command	Action
add <name>	create a new group called `name`, and switch to it.
drop <name>	delete a group by `name`.
name <name>	rename the current group.
dump <file>	export a description (group name and frame layout) of the current group to `file`.
load <file>	import a description from `file` into the current group.
use <name>	switch to the group called `name`.
stack <on\|off>	(toggle) switch the current group between `tiling` and `stacking` window modes.

In `stacking` mode, Windows can be moved using +M+Mouse1+, and resized using +M+Mouse3+.  |More detail|#howto_stacking|.

--- Screen Control

Key bindings:

:table bindings
Keys	Action
M+Tab	switch to the next available screen.

Musca Commands:

:table commands
Command	Action
screen <number>	switch to screen `number`.  This is zero based, and should match the order in which screens are defined in {xorg.conf}.

--- |General Controls\controls_general|

Key bindings:

:table bindings
Keys	Action
M+m	Run a Musca command via dmenu.

Musca commands:

:table commands
Command	Action
exec <command>	execute as shell command.
pad <left> <right> <top> <bottom>	set the current group screen padding in pixels.
bind <on\|off> <Modifier>+<Key> <command>	bind a Musca command to a key combination with `on`, and remove it again with `off`.  The `command` argument is only need for `on`.
set <setting> <value>	set a Musca variable.  See |settings|#settings| for a list of variable names.
quit	exit Musca.

-- |Source\source|

A Musca bazaar repository is available on |launchpad|https://launchpad.net/musca|.  It should always build, but it is a development tree so it may not be stable.

This is the latest dated snapshot considered stable: |musca-0.9.2.tgz|musca-0.9.2.tgz|

--- Build Dependencies:

+ Xlib
+ GNU C Library
+ make
+ gcc

Install the above for your system, grab the source, and run +make+.  Copy the resulting {musca} binary into your {$PATH} somewhere.

--- Runtime Dependencies:

+ dmenu

-- |Author\author|

Feel free to email feedback:

sean dot pringle at gmail dot com

-- |Customize\customize|

Most |settings|#settings| can be changed on the fly using Musca commands, and applied each time using the startup file option.  Alternatively, to change the default settings, modify {config.h} and recompile.

-- |Settings\settings|

Musca has a list of settings that can be altered on the fly using the +set <name> <value>+ command:

 set border_focus Orange

:table musca_settings
Name	Default	Description
border_focus	Blue	Border colour for focused frames in tiling mode, and focused windows in stacking mode.
border_unfocus	Dim Gray	Border colour for unfocused frames in tiling mode, and unfocused windows in stacking mode.
border_dedicate_focus	Red	Border colour for focused `dedicated` frames in tiling mode.
border_dedicate_unfocus	Dark Red	Border colour for unfocused `dedicated` frames in tiling mode.
border_catchall_focus	Green	Border colour for focused `catchall` frames in tiling mode.
border_catchall_unfocus	Dark Green	Border colour for unfocused `catchall` frames in tiling mode.
frame_min_wh	100	Minimum width and height in pixels of frames and managed windows.
frame_resize	20	Size in pixels of a frame resize step.  Setting this smaller will make resizing operations smoother, but also slower and increase load.
startup	.musca_start	(optional) Path to a file containing Musca commands to run at start up.  The default setting is relative to the working directory; ie, Musca will use $HOME/.musca_start `only if Musca is started from $HOME`, which is the usual method for login managers.  The file must contain one command per line.  Lines starting with hash +#+ are comments and blank lines are acceptable.
dmenu	{dmenu -i -b}	Command to run to launch +dmenu+ along with any customize appearance arguments.  This can be replaced by another launcher so long as it accepts a list of +\\n+ terminated items on stdin and returns a single line on stdout.
switch_window	{xargs -I name $MUSCA -c "raise name"}	The command to run once the user has selected a window number and name from +dmenu+.
switch_group	{xargs -I name $MUSCA -c "use name"}	The command to run once the user has selected a group name from +dmenu+.
run_musca_command	{xargs -I command $MUSCA -c "command"}	The command to run when the user has entered a Musca command via +dmenu+.
run_shell_command	{xargs -I command $MUSCA -c "exec command"}	The command to run when the user has entered a shell command via +dmenu+.
notify	{echo %s}	The command to run to send the user a message.  By default Musca just writes to stdout.
stack_mouse_modifier	Mod4	The modifier key to use in `stacking` mode, along with mouse buttons 1 and 3, to move and resize windows respectively.

-- |Howto\howto|

+ |Start Musca|#howto_start|
+ |Use multi-windowed apps like the Gimp|#howto_multi_window_apps|
+ |Change or troubleshoot the Modifier key|#howto_mod_key|
+ |Change the default key combinations|#howto_key_combos|
+ |Change the default border colours|#howto_borders|
+ |Run a system tray|#howto_tray|
+ |Set a desktop background|#howto_background|
+ |Make Musca ignore windows|#howto_ignore|
+ |Use a startup config file|#howto_startup|
+ |Control Musca externally|#howto_control|
+ |Get a list of windows in the current group|#howto_windows|
+ |Use `stacking` window management mode|#howto_stacking|

--- |Start Musca\howto_start|

---- Using startx

Launch it from your +.xinitrc+ file, using +startx+:

 exec /path/to/musca

---- Using a login manager like GDM or KDM

Create /usr/share/xsessions/musca.desktop, and select the Musca session at login:

 [Desktop Entry]
 Encoding=UTF-8
 Type=XSession
 Exec=/path/to/musca
 Name=musca

---- For debugging

Start X with a single xterm running, and launch Musca manually from the xterm, so you can see stdout/stderr (which is where any errors from your dmenu commands will appear).  So in {.xinitrc}:

 exec xterm

--- |Use multi-windowed apps like the Gimp\howto_multi_window_apps|

---- In Tiling Mode

People seem to think this is a huge problem with tiling window managers, but it really is not, particularly in Musca where any old tiling layout can be used and nothing moves around once visible.  |See|musca2.png|?

Start with a single full screen frame and a few small frames off to one side.  Switch to and dedicate the largest frame with +M+d+.  Open the app in the largest frame and the first (hopefully primary) app window will open there, while secondary windows distribute themselves among the smaller frames.  Adjust the number and layout of frames as required for the app in question.  Use the |swap|#controls_window| commands to shift windows around if needs be.

Afterward it may be worthwhile dedicating the smaller frames to ensure they only ever hold the dialog windows you want there, or just set the largest frame as a catch-all to achieve the same effect.

Note that some apps like OpenOffice have windows which are normal dialogs, but they automatically unmap themselves when the primary window is not focussed.  These may flick in and out of existence in the smaller frames.  Not much we can do about it, except use OOo full screen and dock everything with Ctrl+Shift+F10, or use stacking mode.

---- In Stacking Mode

Create a new window group and set it to `stacking` mode with +M+s+, then use the multi-windowed app just as you would in any stacking window manager.  See how the |stacking controls differ|#howto_stacking|.

--- |Change or troubleshoot the Modifier key\howto_mod_key|

Changing the Modifier key is possible by modifying {config.h} and recompiling.  Valid modifier keys are listed in {modmasks[]}, and default key combinations are in {keymaps[]}.  Alternatively, to prevent the need to recompile, you can customize key bindings on the fly using the |+bind+ command|#controls_general|.

Mod4 is commonly bound to X11's +Super_L+ key, which is usually the left Windows key on Linux PCs with a US or UK keyboard layout.  If you're on a different system and the default Modifier key does not work, then establish where mod4 (if it exists!) is pointing by using +xmodmap+:

 $ xmodmap | grep mod4
 mod4        Super_L (0x7f),  Hyper_L (0x80)

Or run the +xev+ utility, press the left Win key, and watch xev's standard output while you do it.  Something like this should appear:

 KeyRelease event, serial 27, synthetic NO, window 0xe00002,
    root 0x259, subw 0x0, time 672433, (417,298), root:(418,299),
    state 0x40, keycode 115 (keysym 0xffeb, Super_L), same_screen YES,
    XLookupString gives 0 bytes:
    XFilterEvent returns: False

Using these two tools, find a suitable Modifier key for your system.

--- |Change the default key combinations\howto_key_combos|

Look at the {keymaps[]} structure in {config.h}.  X11 key names are in X11/keysymdef.h; just remove the 'XK_' from the constant definitions to get the names.  Either modify {keymaps{}} and recompile, or apply key bindings on the fly in {.musca_start} using the |+bind+ command|#controls_general|.

--- |Change the default border colours\howto_borders|

Look at the +border_...+ fields in {settings[]} in {config.h}.  X11 named colours are on |http://en.wikipedia.org/wiki/X11_color_names|http://en.wikipedia.org/wiki/X11_color_names|.  Either modify {settings[]} and recompile, or apply key bindings on the fly in {.musca_start} using the |+set+ command|#controls_general|.

--- |Run a system tray\howto_tray|

Use the +trayer+ utlity and set padding on a window group so as not to obscure it.  For example:

 #!/bin/bash
 trayer --edge bottom --align center --height 32 --SetDockType true --SetPartialStrut false \
  --transparent true --alpha 255 --tint 0x00ff00 --distance 0 --expand true >.trayer.log 2>&1

Whatever system tray application you choose will need to have its WM_CLASS |unmanaged|#howto_ignore|.  Trayer is already unmanaged by default.

--- |Set a desktop background\howto_background|

Musca doesn't touch the root window and frames are transparent, so go use something line +xsetroot+ or +xv+ or +imagemagick+ to set the background.  For example, with imagemagick:

 $ display -window root <path_to_image>

--- |Make Musca ignore windows\howto_ignore|

In {config.h} there is an {unmanaged_windows[]} list of WM_CLASS names:

 char +unmanaged_windows[] = { "trayer", "Xmessage", "Conky" };

Check out the +xprop+ utility to find class names.  Either change {unmanaged_windows[]} and recompile, or do on the fly in {.musca_start} with the |+manage+ command|#controls_window|.  Note that any +manage+ setting only takes effect for `subsequently` opened windows.

--- |Use a startup config file\howto_startup|

Set the `startup` setting in {config.h} to point to a text file of your choice (default is {.musca_start}).  It should contain Musca commands (exactly as would be launched with +M+m+), one per line.  Any comments must be on separate lines starting with hash +#+.  Blank lines are acceptable.  For example:

 manage off trayer
 manage off Conky

 screen 1
 name bling
 pad 0 0 0 32
 exec trayer
 exec conky

 screen 0
 add mail
 add net
 add work
 use mail
 exec firefox gmail.com
 exec evolution
 hsplit 1/2

 set notify notify-send -t 3000 Musca "%s"

Note that lanuching apps from the startup file is OK, but can be of limited use if you want to do it in more than one group.  The +exec+ command runs asynchronously, and if apps are slow to create their windows, they may not necessarily appear in the group you expect.  In this case, try launching apps from {.xinitrc} and just moving them around here.

--- |Control Musca externally\howto_control|

Musca commands can be dispatched from an external script by calling Musca with the {-c <command>} command line argument:

 musca -c "hsplit 1/3"

In this case, the Musca binary will try to connect to an already running instance of Musca, deliver the command, and return once the command has executed.

--- |Get a list of windows in the current group\howto_windows|

Use the group +dump <file>+ command and extract lines starting with the word `window`.  Each line is a series of tab delimited fields in this order:

+ Number in the current group.
+ Class name.
+ Title.

For example:

 #!/bin/bash
 file=/tmp/group.txt
 musca -c "dump $file" && cat $file | grep -r '^window' | awk -F '\t' '{print "id: " $2 " class: " $3 " title: " $4}'

Mould into whatever form suits you.

--- |Use `stacking` window management mode\howto_stacking|

Stacking window management mode is available at the window group level, on a group by group basis.  Select the group you wish to make stacking, and press +M+s+ or run the command +stack on+.  Any frames in the group will disapear.  Other groups will not be affected.

Floating windows can be moved using +M+Mouse1+ -- that is: hold down the modifier key and click the left mouse button on the window -- and dragging the mouse.  Floating windows can be resized using +M+Mouse3+ in the same fashion.  Click-to-focus still works.

Most of the frame manipulation related key combinations and commands are disabled in stacking mode.

No, there is no way to float specific windows while in tiling mode.

To switch the group back to tiling mode, press +M+f+ again or run the command +stack off+.  The group frames will be recreated as they were before the mode change.

-- |+Changelog+\changelog|

+ |0.9.2|#changelog_0.9.2| (|tgz|musca-0.9.2.tgz|)
+ |0.9.1|#changelog_0.9.1| (|tgz|musca-0.9.1.tgz|)
+ |0.9|#changelog_0.9| (|tgz|musca-0.9.tgz|)
+ |20090313|#changelog_20090313| (|tgz|musca_20090313.tgz|)
+ |20090312a|#changelog_20090312a| (|tgz|musca_20090312a.tgz|)
+ |20090312|#changelog_20090312| (|tgz|musca_20090312.tgz|)
+ |20090311|#changelog_20090311| (|tgz|musca_20090311.tgz|)
+ |20090310|#changelog_20090310| (|tgz|musca_20090310.tgz|)
+ |20090309|#changelog_20090309| (|tgz|musca_20090309.tgz|)
+ |20090305|#changelog_20090305| (|tgz|musca_20090305.tgz|)
+ |20090304|#changelog_20090304| (|tgz|musca_20090304.tgz|)
+ |20090303|#changelog_20090303| (|tgz|musca_20090303.tgz|)
+ |20090302|#changelog_20090302| (|tgz|musca_20090302.tgz|)
+ |20090301|#changelog_20090301| (|tgz|musca_20090301.tgz|)

--- |0.9.2\changelog_0.9.2|

+ Tuning: politely check PResizeInc for apps in both stacking and tiling modes.
+ Tuning: changed window resize and drag in stacking mode to use a window outline, to better suit slow video.

--- |0.9.1\changelog_0.9.1|

+ Tuning: prevent parent windows from hiding when transients popup.
+ Bugfix: correctly resize bound keys structure when >31 combinations are bound.

--- |0.9\changelog_0.9|

No difference to |20090313|#changelog_20090313| release, expect that we are starting a more traditional versioning numbering scheme to better suit distro packaging practices.  We're starting at 0.9 because Musca now has all the major features I wanted when starting the project, and bugs seem minimal, but we still need to do extended stability testing.  There is a feature freeze now in effect.

`+Note+ There was some discussion via email that this should be 1.0, and the 0.9 tarball was initially pushed as 1.0.  But after coffee, I think being feature complete and not having many bugs reported doesn't really justify that with a young code base.  So, 0.9 it is.`

--- |20090313\changelog_20090313|

+ Windows now remember their floating position across stacking/tiling mode switches.
+ Bugfix: better MotionNotify co-ordinate checking when resizing in stacking mode.
+ Improved window stacking behavior in relation to unmapped windows, and reduced focus flicker of groups in stacking mode.
+ Improved error checking converting colour names to pixel values for borders.
+ Use {execlp()} instead of {execl()} for launching shell commands with +exec+, to mimic shell parsing and $PATH checking for commands without a full path.
+ Improved key grabbing to prevent blocking some key combinations from the application when we don't need them.

--- |20090312a\changelog_20090312a|

+ |Bugfix|https://bugs.launchpad.net/musca/+bug/341219|: using SIG_IGN for SIGCHLD exits annoys +dbus+ autolaunch, so handle it normally with waitpid.
+ Added additional error check to +bind+ command, to ensure the supplied key symbol is valid.  Previously, it only verified key modifiers.

--- |20090312\changelog_20090312|

+ Cleaned up {config.h}.
+ Replaced various constants with a simple table {settings[]} holding variables that can be set dynamically.
+ Converted {key_callbacks[]} to {keymaps[]} to simply map key strokes to Musca command strings.
+ Added commands: resize, raise, bind, switch, command, shell, set.
+ Added code to filter out NumLock and CapsLock from our key commands (too easy to leave one turned on and disable stuff). Thanks to Nikita Kanounnikov for pointing this bug out.

--- |20090311\changelog_20090311|

+ Tweaked Musca's dmenu usage to execute in a child process.  This should help with the reports made by some people where both dmenu and Musca freeze when the mouse is clicked, or a window opens, while dmenu is running.  Now neither event affects dmenu.
+ Added an {XGrabKeyboard()} check during the Musca startup process.  If it fails, it will throw a warning to {stderr} like:  `Could not temporarily grab keyboard. Something might be blocking key strokes.`  This might help with |this bug|https://bugs.launchpad.net/musca/+bug/336473|.
+ Added the +raise <number\|title>+ command, to raise a window.

--- |20090310\changelog_20090310|

+ Added option to switch window groups between tiling and stacking modes.

--- |20090309\changelog_20090309|

+ Added commands: remove, kill, cycle, only, focus, dedicate, catchall, undo, dump, load, use, exec, swap, screen, manage.  Mnay of these duplicate hot keys, but may be useful to external scripts.
+ Added ability to dump and load group frame layouts to file with +dump <file>+ and +load <file>+ commands.
+ Added the option of a startup script (which needs to be a list of Musca commands), defined by the {STARTUP} definition in {config.h}.
+ Added frame layout `undo` tracking, so that up to 32 frame layout changes per group can be rolled back.
+ Added client command interface for external control by calling {musca -c <command>}
+ Rearranged Musca startup routine slightly to isolate |this bug|https://bugs.launchpad.net/musca/+bug/336473|.
+ Applied a {FOR_RING()} macro to automate looping about head/group/frame/client doubly-linked rings.
+ Improved `click-to-focus` behavior to reduce frame screen flicker.
+ Added restrictions to ensure transient windows follow if their parent is moved between groups.
+ Added logic to prevent a parent window being cycled into another frame when a transient takes focus above it.
+ Added logic to ensure a parent window regains focus in the same frame with a transient window exits.
+ Migrated old {client->kill_event_sent} to a {client->flags} bit.
+ Added ability to manage and unmanage window classes on the fly.
+ Changed {commands[]} struct in {config.h} to a list of command pointers, rather than one long hard to read \\n delimited string.

--- |20090305\changelog_20090305|

---- misc stuff

+ Added TERMINAL to config.h to point to the perferred console app, defaulting to xterm.
+ Added NOTIFY to config.h to point to an external notification app, like {dzen} or {notify-send}.
+ Added example custom launcher functions to config.h, with M+t activated to launch a terminal.
+ Convert {unmananged_windows} to use window class names instead of titles.
+ Reduced default verbosity when logging.

--- |20090304\changelog_20090304|

---- bug fixes

+ Stop frames on an unfocused screen taking the keyboard focus when their client window exited.
+ Fix possible buffer overflow, due to an incorrect {realloc()}, when creating the list of window titles for dmenu.

--- |20090303\changelog_20090303|

---- `width` and `height` commands

Added +width+ and +height+ commands, and {com_frame_size()}, to resize a frame size relative to the screen size or to a specific pixel value.

--- |20090302\changelog_20090302|

---- move windows between groups

Added the +move <group_name>+ command, and {com_window_to_group()}, to move the active window to another group.

---- define a `catch-all` frame

Added +M+a+ key combination, and {frame_catchall()}, to define a frame per group in which +all+ new non-transient windows will open.

--- |20090301\changelog_20090301|

---- key_modifiers

Added {key_modifiers[]} struct to config.h.  This lists the modifier key combinations we're interested in.  Any modifier used in {key_callbacks[]} must also appear in {key_modifiers[]}.

---- key combination logging

Added key combination logging.  Each matched modifier+key combination is logged, eg, a hsplit:

 keypress handling key: Mod4 h

..and each unmatched modifier+key (where modifier is one we're interested in) is logged:

 keypress unhandled key: Mod4 q

This makes it easy to find out X11 key names when modifying {key_callbacks[]}.
-------------------------------------------------------------------
*** Sonstiges
- seit 2009 nichtmehr weiterentwickelt, nur noch Communitypatches
Herbstluft wm kommt dem am nächsten*
** ratpoison :rejected:
- wird nicht mehr weiterentwickelt

** sawfish :rejected:
- war früher mal bei gnome dabei, und die offizielle entwicklung war
  auch mal gestoppt und wird jetzt durch community betrieben

** dwm :rejected:
- sieht sehr schnell aus und scheint auch recht zügig
  on-the-fly neue aufteilung bilden zu können
- zum neukonfigurieren source neu übersetzen?!
- benutzt tags für die Fenster
- wirbt damit, kaum Features zu haben o.O
- keine config-dateien!!
  - das Programm ist aber sehr klein, so dass das überschaubar ist
- da keine jedes mal neu kompilieren kann ein flexibles
  installieren von erweiterungen wohl vergessen werden
  und eingebaut ist dann auch nicht allzu viel

** monsterteil :rejected:
- hardcore kürzungen
** snapswm :rejected:
- sieht an und für sich sauber gemacht aus
aber wieder alles änderungen in dem header => ficken sie sich
** Ion :timefiller:
** StumpWm :timefiller:
** trition
** pekwm

* Coding
** Python
*** Python (in Emacs)
**** Rope
Rope dient dem Refactoring (umbenenenen, grundlegend semantik in
Projekt erkennen und son Zeug). Auch anderer höherer Kram wie das
generieren neuer Funktionen usw. sind möglich. Meine fresse, teilweise
echt geile scheiße dabei.
**** Ropemacs
Bietet interaktive Schnittstellen in Emacs um Rope-refactorings
durchzuführen. Greift dabei auf Pymacs zurück, mit welchem dann
Ropemode Schnittstellen verwendet werden, die dann Rope benutzen.
Ist selbst ebenfalls nur Python => benötigt selbst auch schon
Pymacs.
**** Pymacs
Stellt die Verbindung zwischen Python und ELisp her, in dem die
wichtigsten Funktionalitäten in Wrapper gepackt werden
**** Ropemode
Eine Pythonbibliothek, die Schnittstellen zu Rope liefert (logischerweise
über Python)
*** Python Generell
**** Skriptansatz Automatisierung Ilias
import re
import mechanize
br = mechanize.Browser()
br.open("https://ilias.uni-marburg.de")
#br.retrieve()
print br.select_form(name="formlogin")
br["username"] = "|||username|||"
br["password"] = "|||passwort|||"
responsex = br.submit()
for link in br.links(url_regex="497203[^\n]*cmd=[^1]"):
    if link.text == "Elementare Stochastik":
        print link
        br.follow_link(link)
#br.follow_link("https://ilias.uni-marburg.de/repository.php?ref_id=506449&cmd=view")
br.open("https://ilias.uni-marburg.de/repository.php?ref_id=506449&cmd=view")
br.geturl()
br.response().get_data()
print "check1"
for link in br.links(url_regex="file"):
    if not re.match("Symbol Datei", link.text ):
        print link.text
        print "----"
print "check2"

**** Filemanagement
# The built-in function `open` opens a file and returns a file object.

# Read mode opens a file for reading only.
try:
f = open("file.txt", "r")
try:
# Read the entire contents of a file at once.
string = f.read()
# OR read one line at a time.
line = f.readline()
# OR read all the lines into a list.
lines = f.readlines()
finally:
f.close()
except IOError:
pass


# Write mode creates a new file or overwrites the existing content of the file.
# Write mode will _always_ destroy the existing contents of a file.
try:
# This will create a new file or **overwrite an existing file**.
f = open("file.txt", "w")
try:
f.write('blah') # Write a string to a file
f.writelines(lines) # Write a sequence of strings to a file
finally:
f.close()
except IOError:
pass

# Append mode adds to the existing content, e.g. for keeping a log file. Append
# mode will _never_ harm the existing contents of a file.
try:
# This tries to open an existing file but creates a new file if necessary.
logfile = open("log.txt", "a")
try:
logfile.write('log log log')
finally:
logfile.close()
except IOError:
pass

# There is also r+ (read and write) mode.

** elisp
*** replace in String
(setq var1 (replace-regexp-in-string "old" "new" var1))
*** regex matching
+ (when (org-in-regexp regex 1) (message treffer))
    prüft ob man sich im regex befindet
+ (match-beginning 0) (match-end 0)
    die positionen des letzten funds
+ (matched-string 0) 
    matched den ganzen letzten string bzw. gruppe
*** jump to empty line
**** Next Line Code
(defun jumpToNextEmpty ()
  (interactive)
  (let (var1 moreLines startpoint)
    (setq moreLines (> 2 1))
    (setq startpoint (point))
    (while moreLines
       ;(setq moreLines (= 0 (forward-line 1)))
       ;(forward-line -1)

       ;(message "%s" moreLines)

       ;(setq moreLines (next-line 1))
       ;(setq moreLines (= 0 (next-line 1)))
       (if moreLines
	  (let (p1 p2)
	    (next-line 1)
	    (setq p1 (line-beginning-position))
	    (setq p2 (line-end-position))

	    (when (>= p2 (buffer-size))
	      (setq moreLines (< 2 1))
	      (goto-char startpoint)
	      )

	    (setq var1 (buffer-substring-no-properties p1 p2))
	    (when (string-match "^[ \t]*$" var1)
	       (message var1)
	       (setq moreLines (< 2 1))
	       )
	   )
	 )

       )
    )
 )
**** Prev Line Code
(defun jumpToPrevEmpty ()
  (interactive)
  (let (var1 moreLines startpoint)
    (setq moreLines (> 2 1))
    (setq startpoint (point))
    (while moreLines
       (if moreLines
	  (let (p1 p2)
	    (next-line -1)
	    (setq p1 (line-beginning-position))
	    (setq p2 (line-end-position))

	    (when (<= p1 1)
	      (setq moreLines (< 2 1))
	      (goto-char startpoint)
	      (message "no empty lines found")
	      )

	    (setq var1 (buffer-substring-no-properties p1 p2))
	    (when (string-match "^[ \t]*$" var1)
	       (message var1)
	       (setq moreLines (< 2 1))
	       )
	   )
	 )
       )
    )
 )
*** unique filename
(setq filename
	(concat
	 (make-temp-name
	  (concat 
		  ""
		  (format-time-string "%Y%mad-%H%M%S"))
*** write file
(with-temp-buffer
  (insert (string-as-multibyte "\\test bla"))
  (insert (string-as-multibyte (concat "a" "b" "c")))
  (insert var1)
  (write-region (point-min) (point-max) filename))
*** shell-command
(shell-command
  (concat "latex " filename ".tex"))
*** my-make-latex
(defun my-make-latex ()
  "Convert Region to a Latex image"
  (interactive)
  (setq filename
	(concat
	 (make-temp-name
	  (concat 
		  ""
		  (format-time-string "%Y%mad-%H%M%S")))""))

  (setq stuff (buffer-substring (region-beginning)(region-end)))
  
  (with-temp-buffer
    
    (insert (string-as-multibyte "\\documentclass[11pt]{standalone}"))
    (insert (string-as-multibyte "\\usepackage[utf8]{inputenc}"))
    (insert (string-as-multibyte "\\usepackage{amssymb, amsmath}"))
    (insert (string-as-multibyte "\\begin {document}"))
    (insert (string-as-multibyte "$"))

    (insert stuff)

    (insert (string-as-multibyte "$"))
    (insert (string-as-multibyte "\\end{document}"))

    (write-region (point-min)(point-max) (concat filename ".tex")))
    
  (shell-command
   (concat "latex " filename ".tex"))

  (shell-command
   (concat "dvipng " filename ".dvi -o " filename ".png"))

  (insert (concat "[[file:"filename ".png]]"))
  (iimage-recenter)
)
(provide 'my-make-latex)

*** get selection/region
(setq stuff (buffer-substring (region-beginning)(region-end)))
*** Funktionsaufruf-shortcut durch neuen key ersetzen
(define-key (current-global-map) [remap kill-line] 'my-homemade-kill-line)
*** hartnäckige Bindings überschreiben
die Minormodes habflorianen eine der höchster Prioritäten beim nachschlagen der Keys
-> der jeweilige evil minor mode bietet sich an
Generell gilt: (current-local-map) <= ist ne funktion
Wenn einige Modes ihre Bindings aber trotzdem noch drüberschreiben, muss man sich
selbst an die Hook ketten:
(add-hook 'evil-insert-state-entry-hook
 (lambda ()
 (define-key evil-insert-state-local-map "\M-j" 'evil-window-next)
 (define-key evil-insert-state-local-map "\M-k" 'evil-window-prev)
 )
)

mehr noch bieten sich natürlich die maps des jeweiligen modus
  an, z.b. doc-view-mode-map
  mit describe-mode kommt man zumindest an den mode namen
  zu dem es in der regel eine passende map und hook gibt
*** bedingung
(when (string-match "^ *$" test-str)
   (message "cool")) 
(if (= x y) (message "true") (message "false"))
*** eine Zeile vorwärts
(forward-line 1)   ; oder auch -1
*** hooks
**** Syntax
(add-hook 'latex-mode-hook (lambda () (auto-fill-mode -1)))
**** Standard Hooks
activate-mark-hook
deactivate-mark-hook
after-change-functions
before-change-functions
first-change-hook
after-change-major-mode-hook
change-major-mode-after-body-hook
after-init-hook
before-init-hook
emacs-startup-hook
after-insert-file-functions
write-region-annotate-functions
write-region-post-annotation-function
after-make-frame-functions
before-make-frame-hook
after-save-hook
before-save-hook
write-contents-functions
write-file-functions
after-setting-font-hook
    Hook run after a frame's font changes.
auto-save-hook
before-hack-local-variables-hook
hack-local-variables-hook
buffer-access-fontify-functions
buffer-list-update-hook
    Hook run when the buffer list changes.
buffer-quit-function
    Function to call to “quit” the current buffer.
change-major-mode-hook
command-line-functions
delayed-warnings-hook
    The command loop runs this soon after post-command-hook (q.v.).
delete-frame-functions
delete-terminal-functions
display-buffer-function
pop-up-frame-function
special-display-function
split-window-preferred-function
echo-area-clear-hook
find-file-hook
find-file-not-found-functions
font-lock-extend-after-change-region-function
font-lock-extend-region-functions
font-lock-fontify-buffer-function
font-lock-fontify-region-function
font-lock-mark-block-function
font-lock-unfontify-buffer-function
font-lock-unfontify-region-function
fontification-functions
frame-auto-hide-function
kill-buffer-hook
kill-buffer-query-functions
kill-emacs-hook
kill-emacs-query-functions
menu-bar-update-hook
minibuffer-setup-hook
minibuffer-exit-hook
mouse-leave-buffer-hook
    Hook run when about to switch windows with a mouse command.
mouse-position-function
post-command-hook
pre-command-hook
post-gc-hook
post-self-insert-hook
suspend-hook
suspend-resume-hook
suspend-tty-functions
resume-tty-functions
syntax-begin-function
syntax-propertize-extend-region-functions
syntax-propertize-function
font-lock-syntactic-face-function
temp-buffer-setup-hook
temp-buffer-show-function
temp-buffer-show-hook
term-setup-hook
window-configuration-change-hook
window-scroll-functions
window-size-change-functions
window-setup-hook
window-text-change-functions
**** Org Mode Hooks
[[http://orgmode.org/worg/org-configs/org-hooks.html]]
* Shortcutliste
** einfache Tasten
- AltGr - ü :: Escape
- AltGr - ö :: Tab
- AltGr - p :: enter
** Org - Mode
- C-c C-x C-i :: Clock in
- C-c C-x C-o :: Clock out
- C-c C-x C-c :: cancel Clock
- C-c C-t     :: toggle todo state
- C-c C-x C-r :: Zusammenfassung der Clocks von Substree
- C-u C-c C-x C-i     :: switch Task (nahtloser Wechsel)
- C-u C-u C-c C-x C-i :: Clock in, mark as default (überall reclock in usw.)
- C-c C-x C-d :: An jedem Tree jeweils die Zeit anzeigen
- C-c C-c     :: Update für Ding unter Cursor
- C-c C-x ;   :: Set (und start) Timer
- C-c C-x e   :: set estimated effort time
- C-c C-u     :: Sprung zum Header
- C-j/C-k     :: auf einer Ebene bewegen
- C-ö t       :: org tree to indirect buffer
- C-c C-x C-l :: preview latex fragment (C-c C-c für undo)
- C-ö D       :: display inline images
- C-ä s       :: Screenshot erstellen und einsetzen
- C-ä l       :: konvertiere zu Latex
- C-ä o       :: org-babel-tangle
- C-ä .       :: org-capture
** Expansion/Completion
- C-n,p       :: Evil Extension, zurück
- C-x C-n,p   :: Evil complete line, zurück
- M-ö         :: Hippie expand
- C-ä c       :: mögliche Completions anzeigen
- C-p         :: evil-paste-pop
        geht bei vorherigem paste alle
        elemente des kill-rings durch 
	(kill-ring speichert neue pos)
- C-ö ä       :: magpie expand (beginnt mit , und dann akronyme)
- C-ä ö       :: flosub, entweder aktuelles wort (ab leer oder \n) oder markierung
- C-ä b       :: flosub mit start und end durch leerzeichen getrennt
** sprünge
- g ;         :: springe zu letzter veränderung
- C-ö n/r     :: next/prev Empty Line
- C-ä i/u     :: next/prev regex
- C-ö g/G     :: Vertikalsprung hoch/runter
- M-ä         :: Cursor in Fenster springen lassen
- C-x p ret   :: setze/entferne autonamedbookmark
- C-x j n     :: cycle bookmarks current file
- C-M-n       :: jump up
** Snippets
- C-ä n       :: Neues Snippet
- C-c C-c     :: Snippet Buffer laden
- C-ä f       :: neues Snippet aus Content
- C-ä g       :: Platzhalter erstellen (für Oneshot Snippet)
- C-ä h       :: Oneshot Snippet (erstellen oder einsetzen)
** sonstiges
- C-x * c     :: öffnet calculator
		 => eingabe in postfix/ergebnis paste mit y/close mit q
- C-ö d       :: doc-view-mode
- C-ä k/K     :: encrypt/decrypt region
- S-, S-"     :: minimize(/restore) client
- S-.         :: letzter Tag
- S-Shift-i   :: restore client
- C-x s       :: save-some-buffers 
- M-w         :: buffer back
- C-ä j       :: evil normal state
- C-ä v       :: revert buffer
- C-ü C-q     :: toggle read only
		 
- S-m         :: startet Maus modus
- q        :: start/end dragging
  iae      :: taste 1,2,3
  b        :: lasse maus springen
  u        :: undo
** Fenstermanagement
- C-ä w s     :: Session speichern
- C-ä w r     :: Session laden
- C-ä w u     :: Winner undo
- C-g / C-t 0 :: Popwin Fenster schließen
- C-t         :: Popwin Keymap:
- b           :: Popup Buffer
- l           :: Popup Last Buffer
- s           :: stick Popup Window
- spc         :: select Popup Window
- e           :: show messages
- C-t C-u ... :: zwingt das Fenster zum öffnen in popwin

- C-ü ö b     :: view Buffer other window
- C-ü ö f     :: find file other window
- C-ö b       :: display buffer
- C-ö f       :: display file

- C-ä w d/D   :: dedicate/undedicate window
		 
- C-ä v       :: revert buffer
** helm
- M-m         :: Helm: M-a = alle markieren
- C-ö o       :: Helm Occur (akt. Buffer)
- M-h M-x     :: Helm - M-x -> History usw.
- C-ö s       :: Helm - do - grep
- C-ö k       :: helm show killring
- C-ö h       :: helm apropos
- C-ö i       :: Imenu (Header Übersicht und Sprung)
- C-ö a       :: org-headlines (komplette übersicht)
** emms
- C-ö e n     :: emms-next
- C-ö e p     :: emms-previous
- C-ö e P     :: emms-pause
- C-ö e s     :: emms-shuffle
- C-ö e r     :: emms-repeat
- C-ö e f     :: emms-add-find
- C-ö e d     :: emms-add-directory-tree
- C-ö e l     :: emms-playlist-mode-go
** repeat
- C-x z z...  :: repeat last emacs action
- C-!         :: evil-normale-state (force)
. @@          :: repeat last macro
- C-x r       :: repeat
- C-ä r       :: repeat
** magit
- C-ö m l     :: magit pull
- C-ö m h     :: magit push
- C-ö m s     :: magit status
    s         :: stage
    u         :: unstage
    c C-c C-c :: commit, - absenden
    ll        :: log
		 
** Firefox
- ;y          :: kopiere linkurl
- "+;y        :: kopiere linkurl in clipboard
- A           :: toggle cur bookmark
- :bmarks!    :: bookmarks durchsuchen

 
